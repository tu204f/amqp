__AMQP Transport Architecture__

В этом разделе объясняется, как команды отображаются в протоколе проводного уровня.

__Общее описание__

AMQP - это бинарный протокол. Информация организована в различные типы «frames». Рамки несут методы протокола и другая информация. Все кадры имеют одинаковый общий формат: заголовок кадра, полезная нагрузка, и конец рамы. Формат полезной нагрузки кадра зависит от типа кадра.

Мы предполагаем наличие надежного сетевого транспортного уровня, ориентированного на потоки (TCP / IP или аналогичный).

Внутри одного сокетного соединения может быть несколько независимых потоков управления, называемых «channels». Каждый кадр пронумерован номером канала. Перемежая свои кадры, разные каналы разделяют связь. Для любого данного канала кадры выполняются в строгой последовательности, которая может использоваться для управления протоколом парсер (обычно конечный автомат).

Мы создаем фреймы, используя небольшой набор типов данных, таких как биты, целые числа, строки и таблицы полей. Рамка поля плотно упакованы, что не делает их медленными или сложными для анализа. Относительно просто создать слой кадрирования механически из спецификаций протокола.

Форматирование на уровне проводов спроектировано так, чтобы быть масштабируемым и достаточно универсальным, чтобы его можно было использовать для произвольных высокоуровневых протоколы (не только AMQP). Мы предполагаем, что AMQP будет расширяться, улучшаться и иным образом изменяться time и формат проводного уровня будут поддерживать это.

__Типы данных (Data Types)__

Типы данных AMQP используются при формировании методов и являются:
	-> Целые числа (Integers) (от 1 до 8 октетов), используемые для представления размеров, количества, пределов и т. Д. Целые числа всегда без знака и может быть невыровненным в пределах кадра.
 
	-> Биты (Bits), используемые для представления значений включения/выключения (on/off). Биты упаковываются в октеты.
  
	-> Короткие строки, используемые для хранения свойств короткого текста. Короткие строки ограничены 255 октетами и могут быть анализируется без риска переполнения буфера.
	
	-> Длинные строки, используемые для хранения фрагментов двоичных данных.
	
	-> Таблицы полей, содержащие пары имя-значение. Значения поля набираются в виде строк, целых чисел и т. Д.
	
__Согласование протокола (Protocol Negotiation)__

Клиент и сервер AMQP согласовывают протокол. Это означает, что когда клиент подключается, сервер предлагает определенные варианты, которые клиент может принять или изменить. Когда оба партнера согласны с результатом, соединение идет впереди. Переговоры - полезный метод, потому что он позволяет нам утверждать предположения и предварительные условия.

В AMQP мы согласовываем ряд конкретных аспектов протокола:
	-> Актуальный протокол и версия. Сервер МОЖЕТ размещать несколько протоколов на одном и том же порте.
	-> Аргументы шифрования и аутентификация обеих сторон. Это часть функционального слоя, объяснено ранее.
	-> Максимальный размер кадра, количество каналов и другие рабочие ограничения.
	
Согласованные ограничения MAY позволить обеим сторонам заранее выделить ключевые буферы, избегая взаимоблокировок. Каждый входящий кадр либо подчиняется согласованным ограничениям и поэтому является "безопасным" (safe), либо превышает их, и в этом случае другая сторона ЯВЛЯЕТСЯ (IS) неисправен и ДОЛЖЕН (MUST) быть отключен. Это очень похоже на то, что "либо работает правильно, либо вообще не работает" философия AMQP.

Оба партнера согласовывают пределы минимального согласованного значения следующим образом:
	-> Сервер ДОЛЖЕН (MUST) сообщить клиенту, какие ограничения он предлагает.
	-> Клиент отвечает и МОЖЕТ(MAY) уменьшить эти ограничения для своего соединения.
	
__Ограничение рамок(Delimiting Frames)__
TCP / IP - это потоковый протокол, т.е. нет встроенного механизма разграничения кадров. Существующие протоколы решить эту проблему несколькими способами:
	-> Отправка одного кадра на каждое соединение. Это просто, но медленно.
	-> Добавление в поток разделителей кадров. Это просто, но медленно разбирается.
	-> Подсчет размера фреймов и отправка размера перед каждым фреймом. Это просто и быстро, и наши выбор.
	
2.3.5 Детали рамы (Frame Details)
Все кадры состоят из заголовка (7 октетов), полезной нагрузки произвольного размера и октета конца кадра, который определяет искаженные кадры:
 0      1         3             7 size+7                size+8
 +------+---------+-------------+ +-------------------+ +-----------+
 | type | channel |     size    | | полезная нагрузка | | frame-end |
 +------+---------+-------------+ +-------------------+ +-----------+
   octet   short        long        size octets             octet

Чтобы прочитать фрейм, мы:
1. Прочтите заголовок и проверьте тип кадра и канал.
2. В зависимости от типа кадра мы читаем полезную нагрузку и обрабатываем ее.
3. Считайте октет конца кадра.

В реалистичных реализациях, где важна производительность, мы могли бы использовать «буферизацию с упреждающим чтением» (read-ahead buffering) или «Сбор чтения» (gathering reads), чтобы избежать выполнения трех отдельных системных вызовов для чтения кадра.

2.3.5.1 Кадры метода (Method Frames)

Кадры методу. Полезная нагрузка кадра метода имеет следующий формат:
0          2           4
+----------+-----------+-------------- - -
| class-id | method-id | arguments...
+----------+-----------+-------------- - -
   short       short    ...
   
Чтобы обработать фрейм метода, мы:
1. Прочтите полезную нагрузку кадра метода.
2. Распаковать в конструкцию. Данный метод всегда имеет одинаковую структуру, поэтому мы можем распаковать метод быстро
3. Убедитесь, что метод разрешен в текущем контексте.
4. Убедитесь, что аргументы метода действительны.
5. Выполните метод.

Тела кадра метода состоят из списка полей данных AMQP (битов, целых чисел, строки и строк таблицы). Код маршаллинга тривиально генерируется непосредственно из спецификаций протокола и может быть очень быстро.

2.3.5.2 Фреймы контента (Content Frames)
Контент - это данные приложения, которые мы передаем от клиента к клиенту через сервер AMQP. Контент примерно говоря, набор свойств плюс часть двоичных данных. Набор разрешенных свойств определяется Basic class, и они образуют «фрейм заголовка содержимого». Данные могут быть любого размера и МОГУТ быть разбиты на несколько (или много) фрагментов, каждый из которых образует «фрейм тела содержимого».

Глядя на кадры для определенного канала, когда они проходят по проводу, мы можем увидеть что-то вроде этого:
[method]
[method] [header] [body] [body
[method]

Некоторые методы (такие как Basic.Publish, Basic.Deliver и т. Д.) Формально определены как переносящие контент. Когда одноранговый узел отправляет такой кадр метода, он всегда следует за ним с заголовком содержимого и нулем или более фреймы тела содержимого.

Фрейм заголовка содержимого имеет следующий формат:
0          2        4           12               14
+----------+--------+-----------+----------------+------------- - -
| class-id | weight | body size | property flags | property list...
+----------+--------+-----------+----------------+------------- - -
    short     short   long long     short          remainder...
