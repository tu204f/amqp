## **AMQP**
## **Расширенный протокол очереди сообщений**

Огловнение
1. Обзор
1.1 Цели этого документа
1.2 Резюме
1.2.1 Почему AMQP? 
1.2.2 Объем AMQP
1.2.3 Расширенная модель очереди сообщений (модель AMQ)
1.2.4 Расширенный протокол очереди сообщений (AMQP)
1.2.5 Масштабы развертывания
1.2.6 Функциональные возможности 
1.3 Структура этого документа
1.4 Условные обозначения
1.4.1 Рекомендации для разработчиков 
1.4.2 Нумерация версий 
1.4.3 Техническая терминология 
2. Общая архитектура
2.1 Архитектура модели AMQ
2.1.1 Основные объекты
2.1.2 Поток сообщений 
2.1.3 Биржи
2.1.4 Очереди сообщений
2.1.5 Привязки
2.2 Архитектура команд AMQP
2.2.1 Команды протокола (классы и методы)
2.2.2 Сопоставление AMQP с API промежуточного программного обеспечения

[2.2.3 Нет подтверждений ............................................. .................................................. ...................................... 19](https://translate.googleusercontent.com/translate_f#19)

[2.2.4 Класс подключения ............................................ .................................................. ................................ 19](https://translate.googleusercontent.com/translate_f#19)

[2.2.5 Класс канала ............................................ .................................................. ..................................... 20](https://translate.googleusercontent.com/translate_f#20)

[2.2.6 Обменный класс ............................................ .................................................. ................................... 20](https://translate.googleusercontent.com/translate_f#20)

[2.2.7 Класс очереди ............................................ .................................................. ........................................ 20](https://translate.googleusercontent.com/translate_f#20)

[2.2.8 Базовый класс ............................................ .................................................. .......................................... 21](https://translate.googleusercontent.com/translate_f#21)

[2.2.9 Класс транзакции ............................................ .................................................. ................................ 21](https://translate.googleusercontent.com/translate_f#21)

[2.3 Транспортная архитектура AMQP .............................................. .................................................. ......................... 22](https://translate.googleusercontent.com/translate_f#21)

[2.3.1 Общее описание ............................................. .................................................. .................................. 22](https://translate.googleusercontent.com/translate_f#21)

[2.3.2 Типы данных ............................................. .................................................. ................................................ 22](https://translate.googleusercontent.com/translate_f#22)

[2.3.3 Согласование протокола ............................................. .................................................. .................................. 22](https://translate.googleusercontent.com/translate_f#22)

[2.3.4 Ограничение рамок ............................................. .................................................. ..................................... 23](https://translate.googleusercontent.com/translate_f#22)

[2.3.5 Детали рамы ............................................. .................................................. ............................................ 23](https://translate.googleusercontent.com/translate_f#23)

[2.3.6 Обработка ошибок ............................................. .................................................. .......................................... 24](https://translate.googleusercontent.com/translate_f#24)

[2.3.7 Закрытие каналов и подключений ........................................... .................................................. ............. 24](https://translate.googleusercontent.com/translate_f#24)

[2.4 Клиентская архитектура AMQP .............................................. .................................................. ............................... 25](https://translate.googleusercontent.com/translate_f#24)

[3 Функциональные характеристики ............................................... .................................................. ........................................... 26](https://translate.googleusercontent.com/translate_f#26)

[3.1 Функциональные характеристики сервера .............................................. .................................................. ....................... 26](https://translate.googleusercontent.com/translate_f#26)

[3.1.1 Сообщения и контент ............................................ .................................................. ................................ 26](https://translate.googleusercontent.com/translate_f#26)

[3.1.2 Виртуальные хосты ............................................. .................................................. ............................................. 26](https://translate.googleusercontent.com/translate_f#26)

[3.1.3 Биржи .............................................. .................................................. ................................................. 26](https://translate.googleusercontent.com/translate_f#26)

[3.1.4 Очереди сообщений ............................................. .................................................. ........................................ 28](https://translate.googleusercontent.com/translate_f#28)

[3.1.5 Привязки .............................................. .................................................. .................................................. .29](https://translate.googleusercontent.com/translate_f#29)

[3.1.6 Потребители .............................................. .................................................. ................................................ 29](https://translate.googleusercontent.com/translate_f#29)

[3.1.7 Качество обслуживания ............................................ .................................................. ...................................... 29](https://translate.googleusercontent.com/translate_f#29)

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 4 из 39

---

**Стр. 5**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

[3.1.8 Благодарности .............................................. .................................................. .................................. 29](https://translate.googleusercontent.com/translate_f#29)

[3.1.9 Управление потоком ............................................. .................................................. ............................................. 29](https://translate.googleusercontent.com/translate_f#29)

[3.1.10 Соглашения об именах ............................................. .................................................. ............................... 29](https://translate.googleusercontent.com/translate_f#29)

[3.2 Спецификация команд AMQP (классы и методы) ......................................... ........................................... 30](https://translate.googleusercontent.com/translate_f#30)

[3.2.1 Пояснительные примечания ............................................. .................................................. ..................................... 30](https://translate.googleusercontent.com/translate_f#30)

[3.2.2 Сведения о классе и методе ........................................... .................................................. ........................... 30](https://translate.googleusercontent.com/translate_f#30)

[4 Технические характеристики ............................................... .................................................. ........................................... 31](https://translate.googleusercontent.com/translate_f#31)

[4.1 Номер порта, назначенный IANA ............................................. .................................................. ............................ 31](https://translate.googleusercontent.com/translate_f#31)

[4.2 Формат уровня проводов AMQP ............................................ .................................................. ................................ 31](https://translate.googleusercontent.com/translate_f#31)

[4.2.1 Формальная грамматика протокола ............................................ .................................................. .......................... 31](https://translate.googleusercontent.com/translate_f#31)

[4.2.2 Заголовок протокола ............................................. .................................................. ......................................... 33](https://translate.googleusercontent.com/translate_f#32)

[4.2.3 Общий формат кадра ............................................ .................................................. ............................... 33](https://translate.googleusercontent.com/translate_f#33)

[4.2.4 Полезные данные метода ............................................. .................................................. ....................................... 34](https://translate.googleusercontent.com/translate_f#34)

[4.2.5 Поля данных AMQP ............................................ .................................................. ..................................... 34](https://translate.googleusercontent.com/translate_f#34)

[4.2.6 Контент-фрейминг ............................................. .................................................. ........................................ 36](https://translate.googleusercontent.com/translate_f#35)

[4.2.7 Кадры тактового сигнала ............................................. .................................................. ...................................... 37](https://translate.googleusercontent.com/translate_f#36)

[4.3 Мультиплексирование каналов ............................................... .................................................. ...................................... 37](https://translate.googleusercontent.com/translate_f#37)

[4.4 Гарантия видимости ............................................... .................................................. ......................................... 38](https://translate.googleusercontent.com/translate_f#37)

[4.5 Закрытие канала ............................................... .................................................. ............................................... 38](https://translate.googleusercontent.com/translate_f#37)

[4.6 Синхронизация контента ............................................... .................................................. .................................. 38](https://translate.googleusercontent.com/translate_f#38)

[4.7 Гарантии заказа контента .............................................. .................................................. ........................... 38](https://translate.googleusercontent.com/translate_f#38)

[4.8 Обработка ошибок ............................................... .................................................. ................................................. 38](https://translate.googleusercontent.com/translate_f#38)

[4.8.1 Исключения .............................................. .................................................. ................................................ 38](https://translate.googleusercontent.com/translate_f#38)

[4.8.2 Формат кода ответа ............................................ .................................................. .................................... 39](https://translate.googleusercontent.com/translate_f#38)

[4.9 Ограничения ................................................ .................................................. .................................................. .... 39](https://translate.googleusercontent.com/translate_f#39)

[4.10 Безопасность ................................................ .................................................. .................................................. ....... 39](https://translate.googleusercontent.com/translate_f#39)

[4.10.1 Цели и принципы ............................................ .................................................. ................................. 39](https://translate.googleusercontent.com/translate_f#39)

[4.10.2 Атаки отказа в обслуживании ........................................... .................................................. ......................... 39](https://translate.googleusercontent.com/translate_f#39)

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 5 из 39

---

**Стр. 6**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Обзор

1 Обзор

**1.1 Цели этого документа**

Этот документ определяет сетевой протокол, Advanced Message Queuing Protocol (AMQP), который

позволяет соответствующим клиентским приложениям взаимодействовать с соответствующими серверами промежуточного программного обеспечения обмена сообщениями.

Мы обращаемся к технической аудитории, имеющей некоторый опыт в данной области, и обеспечиваем достаточный

спецификации и руководящие принципы, по которым квалифицированный инженер может построить соответствующие решения в любых

современный язык программирования или аппаратная платформа.

**1.2 Резюме**

1.2.1 Почему AMQP?

AMQP обеспечивает полную функциональную совместимость между соответствующими клиентами и промежуточным ПО для обмена сообщениями.

серверы (также называемые «брокерами»).

Наша цель - обеспечить разработку и повсеместное использование стандартизированного промежуточного программного обеспечения для обмена сообщениями.

технология, которая снизит затраты на корпоративную и системную интеграцию и обеспечит промышленный уровень

интеграционные услуги для широкой аудитории. Наша цель, чтобы через промежуточное ПО для обмена сообщениями AMQP

В конечном итоге возможности могут быть реализованы в самой сети, и это за счет повсеместной доступности

ПО промежуточного слоя для обмена сообщениями могут быть разработаны новые виды полезных приложений.

1.2.2 Объем AMQP

Для обеспечения полной совместимости промежуточного программного обеспечения обмена сообщениями требуется, чтобы сетевой протокол

и семантика серверных служб достаточно определена. AMQP, таким образом, определяет как

сетевой протокол и сервисы на стороне сервера через:

◆ **определенный набор возможностей обмена сообщениями**

называется "Расширенный протокол очереди сообщений"

Модель "(модель AMQ). Модель AMQ состоит из набора компонентов, которые маршрутизируют и хранят сообщения.

внутри брокерской службы, а также набор правил для соединения этих компонентов друг с другом.

◆ **сетевой протокол провод уровня,** AMQP, что позволяет клиентским приложениям взаимодействовать с сервером и взаимодействуют между собой

с моделью AMQ, которую он реализует.

Можно частично подразумевать семантику сервера из спецификаций протокола AMQP, но мы полагаем

что явное описание этой семантики помогает пониманию протокола.

1.2.3 Расширенная модель очереди сообщений (модель AMQ)

Мы явно определяем семантику сервера, поскольку для взаимодействия требуется, чтобы они были одинаковыми в любых

данная серверная реализация. Таким образом, модель AMQ определяет модульный набор компонентов и стандартные

правила их подключения. В процессинг включаются три основных типа компонентов.

цепочки на сервере для создания желаемой функциональности:

◆ « **Обмен** » получает сообщения от приложений издателя и направляет их в «очереди сообщений»,

на основе произвольных критериев, обычно свойств или содержимого сообщения.

◆ « **Очередь сообщений** » хранит сообщения до тех пор, пока они не будут безопасно обработаны клиентом-потребителем.

приложение (или несколько приложений).

◆ « **Привязка** » определяет отношения между очередью сообщений и обменом и обеспечивает

критерии маршрутизации сообщений.

Используя эту модель, мы можем эмулировать классические концепции промежуточного программного обеспечения, ориентированного на сообщения, - store-and-forward.

очереди и подписки на темы банально. Мы также можем выражать менее тривиальные концепции, такие как основанные на содержании

маршрутизация, распределение нагрузки и очереди сообщений по запросу.

В общих чертах, сервер AMQP аналогичен серверу электронной почты, при этом каждая биржа действует как

агент передачи сообщений и каждую очередь сообщений в качестве почтового ящика. Привязки определяют таблицы маршрутизации в

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 6 из 39

---

**Стр.7**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Обзор

каждый трансфер-агент. Издатели отправляют сообщения отдельным агентам передачи, которые затем маршрутизируют сообщения.

в почтовые ящики. Потребители берут сообщения из почтовых ящиков. Во многих промежуточных системах до AMQP

напротив, издатели отправляют сообщения непосредственно в отдельные почтовые ящики (в случае с промежуточным хранением

очереди) или в списки рассылки (в случае подписок на темы).

Разница в том, что когда правила, связывающие очереди сообщений с биржами, находятся под контролем

архитектором (а не встроенным в код), становится возможным делать интересные вещи, например определять правило

который говорит: «поместите копии всех сообщений, содержащих такой-то заголовок, в эту очередь сообщений».

При разработке модели AMQ руководствовались следующими основными требованиями:

◆ Поддерживать семантику, сопоставимую с основными продуктами для обмена сообщениями.

◆ Обеспечить уровень производительности, сопоставимый с основными продуктами для обмена сообщениями.

◆ Разрешить программирование конкретной семантики сервера приложением через протокол.

◆ Быть гибким и расширяемым, но простым.

1.2.4 Расширенный протокол очереди сообщений (AMQP)

Протокол AMQP - это бинарный протокол с современными функциями: он многоканальный, согласованный,

асинхронный, безопасный, портативный, нейтральный и эффективный. AMQP удобно разделить на два уровня:

+ ------------------ Функциональный уровень ---------------- +

|

|

| Основные операции Обмены Очереди сообщений |

|

|

+ ------------------------------------------------- - +

+ ------------------ Транспортный уровень ----------------- +

|

|

| Кадрирование представления данных содержимого

|

|

|

| Обработка ошибок Сердцебиение каналов |

|

|

+ ------------------------------------------------- - +

Функциональный уровень определяет набор команд (сгруппированных в логические классы функциональности), которые действительно полезны.

работать от имени приложения.

Транспортный уровень, который передает эти методы от приложения к серверу и обратно, и который обрабатывает

мультиплексирование каналов, кадрирование, кодирование контента, биение сердца, представление данных и обработка ошибок.

Можно заменить транспортный уровень произвольным транспортом без изменения видимого в приложении

функциональность протокола. Можно также использовать один и тот же транспортный уровень для разных протоколов высокого уровня.

При разработке модели AMQ руководствовались следующими требованиями:

◆ Гарантировать совместимость между соответствующими реализациями.

◆ Обеспечить явный контроль качества обслуживания.

◆ Быть последовательным и ясным в именовании.

◆ Разрешить полную настройку проводки сервера по протоколу.

◆ Использовать нотацию команд, которая легко отображается в API уровня приложения.

◆ Чтобы было ясно, каждая операция выполняет только одно действие.

При разработке транспортного уровня AMQP руководствовались этими основными требованиями без определенного порядка:

◆ Быть компактным, использовать двоичную кодировку для быстрой упаковки и распаковки.

◆ Для обработки сообщений любого размера без значительных ограничений.

◆ Для передачи нескольких каналов через одно соединение.

◆ Быть долговечным, без существенных встроенных ограничений.

◆ Разрешить асинхронный командный конвейер.

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 7 из 39

---

**Стр. 8**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Обзор

◆ Быть легко расширяемым для удовлетворения новых и изменившихся потребностей.

◆ Для дальнейшей совместимости с будущими версиями.

◆ Поддается ремонту с использованием сильной модели утверждений.

◆ Быть нейтральным по отношению к языкам программирования.

◆ Чтобы соответствовать процессу генерации кода.

1.2.5 Масштабы развертывания

Объем AMQP охватывает различные уровни масштаба, примерно следующим образом:

◆ Разработчик / случайное использование: 1 сервер, 1 пользователь, 10 очередей сообщений, 1 сообщение в секунду.

◆ Производственное приложение: 2 сервера, 10-100 пользователей, 10-50 очередей сообщений, 10 сообщений в секунду (36K

сообщений / час).

◆ Критически важное приложение для подразделения: 4 сервера, 100-500 пользователей, 50-100 очередей сообщений, 100

сообщений в секунду (360К / час).

◆ Региональное критически важное приложение: 16 серверов, 500–2000 пользователей, 100–500 очередей сообщений и тем,

1000 сообщений в секунду (3,6 млн / час).

◆ Глобальное критически важное приложение: 64 сервера, 2–10 тыс. Пользователей, 500–1000 очередей сообщений и тем,

10000 сообщений в секунду (36M / час).

◆ Рыночные данные (торговля): 200 серверов, 5K пользователей, 10K тем, 100K сообщений в секунду (360M / час).

Помимо объема, очень важна задержка передачи сообщений. Например, рыночные данные

приходит в негодность очень быстро. Реализации могут отличаться друг от друга, предоставляя разные

Качество обслуживания или возможности управления при полном соответствии с данной спецификацией.

1.2.6 Функциональный объем

Мы хотим поддерживать различные архитектуры обмена сообщениями:

◆ Магазин и вперед со многими писателями и одним читателем.

◆ Распределение нагрузки с большим количеством писателей и читателей.

◆ Публикуйте-подписывайтесь со многими писателями и многими читателями.

◆ Контентная маршрутизация с множеством писателей и читателей.

◆ Очередь передачи файлов с множеством писателей и читателей.

◆ Соединение точка-точка между двумя узлами.

◆ Распространение рыночных данных с множеством источников и читателей.

**1.3 Структура этого документа**

Документ разделен на пять глав, большинство из которых предназначены для самостоятельного чтения в соответствии с

на ваш уровень интереса:

1. « **Обзор** » (данная глава). Прочтите эту главу для введения.

2. « **Общая архитектура** », в которой мы описываем архитектуру и общий дизайн AMQP. Этот

Глава предназначена для того, чтобы помочь системным архитекторам понять, как работает AMQP.

3. « **Функциональные спецификации** », в которых мы определяем, как приложения работают с AMQP. Эта глава

состоит из удобочитаемого обсуждения, за которым следует подробное описание каждой команды протокола,

предназначен в качестве справочного материала для разработчиков. Перед чтением этой главы вы должны прочитать Общие

Архитектура.

4. « **Технические спецификации** », в которых мы определяем, как работает транспортный уровень AMQP. Эта глава

состоит из краткого обсуждения, за которым следует подробное описание конструкций на уровне проводов, предназначенных для

в качестве справочника для разработчиков. Вы можете прочитать эту главу отдельно, если хотите понять, как

протокол проводного уровня работает (но не то, для чего он используется).

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 8 из 39

---

**Стр.9**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Обзор

**1.4 Условные обозначения**

1.4.1 Рекомендации для разработчиков

◆ Мы используем термины ДОЛЖЕН, НЕ ДОЛЖЕН, ДОЛЖЕН, НЕ ДОЛЖЕН и МОЖЕТ, как определено IETF.

RFC 2119.

◆ Мы используем термин «сервер» при обсуждении конкретного поведения, необходимого для соответствующего AMQP.

сервер.

◆ Мы используем термин «клиент» при обсуждении конкретного поведения, требуемого от соответствующего AMQP.

клиент.

◆ Мы используем термин «партнер» для обозначения «сервера или клиента».

◆ Все числовые значения являются десятичными, если не указано иное.

◆ Константы протокола отображаются в виде имен в верхнем регистре. Реализации AMQP ДОЛЖНЫ использовать эти имена

при определении и использовании констант в исходном коде и документации.

◆ Имена свойств, аргументы метода и поля фрейма отображаются в нижнем регистре. AMQP

реализации ДОЛЖНЫ использовать эти имена последовательно в исходном коде и документации.

◆ Строки в AMQP чувствительны к регистру. Например, «amq.Direct» указывает на обмен, отличный от

«Amq.direct».

1.4.2 Нумерация версий

Версия AMQP выражается двумя или тремя цифрами - старший номер, младший номер и

необязательный номер редакции. По соглашению версия обозначается как _мажор-минор_ [ _-revision_ ] или

_major.minor [.revision]_ :

◆ Старшие, второстепенные номера и номера ревизии могут принимать любое значение от 0 до 99 для официальных спецификаций.

◆ Старший, младший и номер ревизии от 100 и выше зарезервированы для внутреннего тестирования и разработки.

целей.

◆ Номера версий указывают на синтаксическую и семантическую совместимость.

◆ Версия 0-9-1 представлена ​​как основной = 0, второстепенный = 9, редакция = 1.

◆ Версия 1.1 будет представлена ​​как основной = 1, второстепенный = 1, редакция = 0. Запись «AMQP / 1.1» означает

эквивалентно записи «AMQP / 1.1.0» или AMQP / 1-1-0.

1.4.3 Техническая терминология

Эти термины имеют особое значение в контексте этого документа:

◆ **Архитектура команд AMQP:** закодированная команда протокола проводного уровня, которая выполняет действия на

состояние архитектуры модели AMQ.

◆ **Архитектура модели AMQ:** логическая структура, представляющая ключевые сущности и семантику, которые

должен быть доступен с помощью реализации сервера, совместимого с AMQP, чтобы состояние сервера могло

клиент может манипулировать им для достижения семантики, определенной в этой спецификации.

◆ **Соединение** : сетевое соединение, например соединение через сокет TCP / IP.

◆ **Канал** : двунаправленный поток обмена данными между двумя узлами AMQP. Каналы

мультиплексированы, так что одно сетевое соединение может передавать несколько каналов.

◆ **Клиент** : инициатор соединения или канала AMQP. AMQP не симметричен. Клиенты производят

и потребляют сообщения, пока серверы ставят в очередь и маршрутизируют сообщения.

◆ **Сервер** : процесс, который принимает клиентские подключения и реализует очередь сообщений AMQP и

функции маршрутизации. Также известен как «брокер».

◆ **Одноранговый узел** : любая сторона в соединении AMQP. В соединении AMQP участвуют ровно два одноранговых узла (один из них

клиент, один - сервер).

◆ **Фрейм** : официально определенный пакет данных подключения. Кадры всегда пишутся и читаются

непрерывно - как единое целое - на соединении.

◆ **Класс протокола** : набор команд AMQP (также известных как методы), которые имеют дело с определенным

тип функциональности.

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 9 из 39

---

**Стр.10**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Обзор

◆ **Метод** : особый тип кадра команды AMQP, который передает инструкции от одного партнера к другому.

◆ **Содержимое** : данные приложения передаются от клиента к серверу и от сервера к клиенту. Срок

синоним слова "сообщение".

◆ **Заголовок содержимого** : конкретный тип фрейма, который описывает свойства содержимого.

◆ **Тело содержимого** : конкретный тип фрейма, который содержит необработанные данные приложения. Фреймы тела содержимого

полностью непрозрачны - сервер никоим образом не проверяет и не изменяет их.

◆ **Сообщение** : синоним «содержания».

◆ **Exchange** : объект на сервере, который получает сообщения от приложений-производителей и

необязательно направляет их в очереди сообщений на сервере.

◆ **Тип обмена** : алгоритм и реализация конкретной модели обмена. В отличие от

«экземпляр обмена», который является объектом, который получает и направляет сообщения на сервере.

◆ **Очередь сообщений** : именованный объект, который хранит сообщения и пересылает их приложениям-потребителям.

◆ **Связывание** : объект, который создает связь между очередью сообщений и обменом.

◆ **Ключ маршрутизации** : виртуальный адрес, который обмен может использовать, чтобы решить, как маршрутизировать конкретное сообщение.

◆ **Долговечный** : ресурс сервера, который выживает после перезапуска сервера.

◆ **Переходный процесс** : ресурс сервера или сообщение, которое стирается или сбрасывается после перезапуска сервера.

◆ **Постоянное** : сообщение о том, что сервер хранит надежное дисковое хранилище и НЕ ДОЛЖЕН потеряться после

перезапуск сервера.

◆ **Потребитель** : клиентское приложение, которое запрашивает сообщения из очереди сообщений.

◆ **Производитель** : клиентское приложение, которое публикует сообщения для обмена.

◆ **Виртуальный хост** : набор обменов, очередей сообщений и связанных объектов. Виртуальные хосты

независимые серверные домены, которые используют общую среду аутентификации и шифрования.

◆ **Утверждение** : условие, которое должно выполняться для продолжения обработки.

◆ **Исключение** : неудачное утверждение, обработанное закрытием канала или соединения.

Эти термины не имеют особого значения в контексте AMQP:

◆ **Тема** : Обычно средство распространения сообщений; AMQP реализует темы, используя один или несколько типов

обмен.

◆ **Подписка** : Обычно запрос на получение данных из тем; AMQP реализует подписки как

очереди сообщений и привязки.

◆ **Сервис** : Обычно синонимичен с сервером. AMQP использует «сервер», чтобы соответствовать стандарту IETF.

номенклатура.

◆ **Брокер:** синоним сервера. AMQP использует термины «клиент» и «сервер» в соответствии с IETF.

стандартная номенклатура.

◆ **Маршрутизатор** : иногда используется для описания действий обмена. Биржи также могут выступать в качестве сообщений

конечные точки, а «маршрутизатор» имеет особое значение в сетевом домене, поэтому AMQP не использует его.

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 10 из 39

---

**Стр. 11**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Общая архитектура

2 Общая архитектура

**2.1 Архитектура модели AMQ**

В этом разделе объясняется семантика сервера, которая должна быть стандартизирована, чтобы гарантировать совместимость.

между реализациями AMQP.

2.1.1 Основные объекты

На этой диаграмме показана общая модель AMQ:

Сервер

+ ---------------------------- +

|

Виртуальный хост

|

| + ------------------- + |

| | Обмен | |

+ ------------- + | | + ------- + | |

| Издатель | ----------> |

| | |

| приложение | | | + --- + --- + | |

+ ------------- + | |

|

| |

| | Сообщение | |

| |

Очередь

| |

+ ------------- + | | + ------- + | |

| Потребитель | <---------- + ------- + | |

| приложение | | | + ------- + | |

+ ------------- + | | + ------- + | |

| + ------------------- + |

+ ---------------------------- +

Мы можем резюмировать, что такое промежуточный сервер: это сервер данных, который принимает сообщения и выполняет два

главное с ними, он направляет их разным потребителям в зависимости от произвольных критериев и буферизует

их в памяти или на диске, когда потребители не могут их принять достаточно быстро.

На сервере до AMQP эти задачи выполняются монолитными механизмами, реализующими определенные типы маршрутизации.

и буферизация. Модель AMQ использует подход меньших модульных элементов, которые можно комбинировать в

более разнообразными и надежными способами. Он начинается с разделения этих задач на две отдельные роли:

◆ Обмен, который принимает сообщения от производителей и направляет им очереди сообщений.

◆ Очередь сообщений, в которой хранятся сообщения и пересылаются их приложениям-потребителям.

Между обменом и очередью сообщений существует четкий интерфейс, называемый «привязкой», к которому мы и перейдем.

потом. AMQP обеспечивает семантику, программируемую во время выполнения, по двум основным аспектам:

1. Возможность во время выполнения через протокол создавать произвольные типы обмена и очереди сообщений (некоторые из них

определены в стандарте, но другие могут быть добавлены как расширения сервера).

2. Возможность во время выполнения через протокол связывать обмены и очереди сообщений вместе для создания любых

необходимая система обработки сообщений.

2.1.1.1 Очередь сообщений

Очередь сообщений хранит сообщения в памяти или на диске и последовательно доставляет их одному или нескольким

потребительские приложения. Очереди сообщений - это объекты хранения и распределения сообщений. Каждая очередь сообщений

полностью независимый и достаточно умный объект.

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 11 из 39

---

**Стр. 12**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Общая архитектура

Очередь сообщений имеет различные свойства: частные или общие, постоянные или временные, с именем клиента или на сервере.

с именем и т. д. Выбрав нужные свойства, мы можем использовать очередь сообщений для реализации обычных

объекты промежуточного программного обеспечения, такие как:

◆ Общая **очередь с** промежуточным **хранением** , в которой хранятся сообщения и которые распределяются между потребителями.

на круговой основе. Очереди хранения и пересылки обычно долговечны и разделяются между несколькими

потребители.

◆ A **личного очередь ответа** , который содержит сообщения и пересылает их к одному потребителю. Очереди ответов

обычно являются временными, именуются сервером и являются частными для одного потребителя.

◆ **частной очередь подписки** , которая содержит сообщения , собранные из различных «подписалась» источники, и

пересылает их одному потребителю.

Очереди подписки обычно временные, именуются сервером и являются частными для одного потребителя. Эти категории

формально не определены в AMQP: они являются примерами использования очередей сообщений. Это тривиально

создавать новые объекты, такие как долговечные общие очереди подписки.

2.1.1.2 Обмен

Обмен принимает сообщения от приложения-производителя и направляет их в очереди сообщений в соответствии с

по заранее установленным критериям. Эти критерии называются «привязками». Биржи - это механизмы сопоставления и маршрутизации.

То есть они проверяют сообщения и, используя свои таблицы привязки, решают, как пересылать эти сообщения в

очереди сообщений или другие обмены. Биржи никогда не хранят сообщения.

Термин «обмен» используется для обозначения как класса алгоритма, так и экземпляров такого алгоритма.

Вернее, мы говорим о «типе обмена» и «экземпляре обмена».

AMQP определяет ряд стандартных типов обмена, которые охватывают основные типы необходимой маршрутизации.

сделать обычную доставку сообщений. Серверы AMQP будут предоставлять экземпляры этих обменов по умолчанию.

Приложения, использующие AMQP, могут дополнительно создавать свои собственные экземпляры обмена. Типы обмена

названы так, чтобы приложения, которые создают свои собственные обмены, могли сообщить серверу, какой тип обмена использовать.

Экземпляры Exchange также имеют имена, чтобы приложения могли указывать, как связывать очереди и публиковать

Сообщения.

Биржи могут делать больше, чем просто направлять сообщения. Они могут действовать как интеллектуальные агенты, работающие изнутри

сервер, принимая сообщения и создавая сообщения по мере необходимости. Концепция обмена предназначена для определения

модель для добавления расширяемости к серверам AMQP достаточно стандартным способом, поскольку расширяемость

некоторое влияние на совместимость.

2.1.1.3 Ключ маршрутизации

В общем случае обмен рассматривает свойство сообщения, с его полем заголовка, и его содержание в организме,

и, используя эти и, возможно, данные из других источников, решает, как направить сообщение.

В большинстве простых случаев биржа проверяет одно ключевое поле, которое мы называем «ключом маршрутизации».

Ключ маршрутизации - это виртуальный адрес, который биржа может использовать, чтобы решить, как маршрутизировать сообщение.

Для двухточечной маршрутизации ключ маршрутизации - это обычно имя очереди сообщений.

Для маршрутизации публикаций и подписок тем ключом маршрутизации обычно является значением иерархии темы.

В более сложных случаях ключ маршрутизации может быть объединен с маршрутизацией по полям заголовка сообщения и / или его

содержание.

2.1.1.4 Аналогия с электронной почтой

Если мы проведем аналогию с системой электронной почты, мы увидим, что концепции AMQP не радикальны:

◆ сообщение AMQP аналогично сообщению электронной почты;

◆ очередь сообщений подобна почтовому ящику;

◆ потребитель подобен почтовому клиенту, который получает и удаляет электронную почту;

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 12 из 39

---

**Стр. 13**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Общая архитектура

◆ обмен похож на MTA (агент пересылки почты), который проверяет электронную почту и принимает решение на основе маршрутизации

ключи и таблицы, как отправить письмо в один или несколько почтовых ящиков;

◆ ключ маршрутизации соответствует адресу электронной почты To: или Cc: или Bcc: без информации о сервере.

(маршрутизация полностью внутренняя по отношению к серверу AMQP);

◆ каждый экземпляр обмена похож на отдельный процесс MTA, обрабатывающий некоторый субдомен электронной почты или конкретный

тип почтового трафика;

◆ привязка подобна записи в таблице маршрутизации MTA.

Сила AMQP заключается в нашей способности создавать очереди (почтовые ящики), обмены (процессы MTA),

и привязки (записи маршрутизации) во время выполнения, и связать их вместе способами, которые выходят далеко за рамки простого

отображение адреса "в" на имя почтового ящика.

Не стоит заходить слишком далеко с аналогией электронной почты и AMQP: есть фундаментальные различия. Проблема в

AMQP предназначен для маршрутизации и хранения сообщений на сервере, или язык SMTP (IETF RFC 821) вызывает их

«Автономные системы». Напротив, в электронной почте проблема заключается в маршрутизации сообщений между автономными

системы.

Маршрутизация внутри сервера и между серверами - разные проблемы и имеют разные решения, хотя бы для

банальные причины вроде сохранения прозрачности показателей.

Для маршрутизации между серверами AMQP, принадлежащими разным объектам, устанавливаются явные мосты, где один

Сервер AMQP действует и клиент другого сервера с целью передачи сообщений между этими

отдельные объекты. Такой способ работы, как правило, подходит для тех видов бизнеса, в которых ожидается использование AMQP.

используется, потому что эти мосты, вероятно, будут поддерживаться бизнес-процессами, договорными обязательствами и

проблемы безопасности.

2.1.2 Поток сообщений

На этой диаграмме показан поток сообщений через сервер модели AMQ:

+ ------------- +

+ ------- +

| Издатель | -----------------> | Сообщение |

| приложение |

+ --- + --- +

+ ------------- +

|

|

+ --------- +

| Обмен |

+ ---- + ---- +

|

+ ------------ + ------------ +

|

|

|

Сообщение Сообщение Сообщение

Очередь

Очередь

Очередь

+ ------------- +

+ ------- + + ------- + + ------- +

| Потребитель |

+ ------- + + ------- + + ------- +

| приложение | <---- | Сообщение | + ------- + + ------- +

+ ------------- +

+ ------- + + ------- + + ------- +

2.1.2.1 Жизненный цикл сообщения

Сообщение AMQP состоит из набора свойств и непрозрачного содержимого.

Новое «сообщение» создается приложением-производителем с использованием клиентского API AMQP. Производитель размещает

«Контент» в сообщении и, возможно, задает некоторые «свойства» сообщения. Производитель маркирует сообщение

с «маршрутной информацией», которая внешне похожа на адрес, но практически любая схема может быть

созданный. Затем производитель отправляет сообщение в «обмен» на сервере.

Когда сообщение поступает на сервер, обмен (обычно) направляет сообщение в набор сообщений.

«очереди», которые также существуют на сервере. Если сообщение не маршрутизируемо, обмен может отбросить его без уведомления или

верните производителю. Производитель выбирает, как обрабатывать немаршрутизируемые сообщения.

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 13 из 39

---

**Стр. 14**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Общая архитектура

Одно сообщение может существовать на многих очередей сообщений. Сервер может справиться с этим по-разному, с помощью

копирование сообщения с использованием подсчета ссылок и т. д. Это не влияет на совместимость. Тем не мение,

когда сообщение направляется в несколько очередей сообщений, оно идентично в каждой очереди сообщений. Здесь нет

уникальный идентификатор, который отличает различные копии.

Когда сообщение поступает в очередь сообщений, очередь сообщений пытается немедленно передать его потребителю.

приложение через AMQP. Если это невозможно, очередь сообщений хранит сообщения (в памяти или на диске

по запросу производителя) и ожидает готовности потребителя. Если нет потребителей, сообщение

queue может вернуть сообщение производителю через AMQP (опять же, если производитель попросил об этом).

Когда очередь сообщений может доставить сообщение потребителю, она удаляет сообщение из своей внутренней

буферы. Это может произойти сразу же или после того, как потребитель подтвердит, что он успешно

обработал сообщение. Потребитель выбирает, как и когда сообщения «подтверждаются». В

потребитель также может отклонить сообщение (отрицательное подтверждение).

Сообщения производителя и подтверждения потребителя сгруппированы в «транзакции». Когда приложение

играет обе роли, что часто бывает смешанным: отправка сообщений и отправка подтверждений,

а затем совершить или откатить транзакцию.

Доставка сообщений с сервера потребителю не осуществляется; достаточно провести

благодарности к этим сообщениям

2.1.2.2 Что видит продюсер

По аналогии с системой электронной почты мы видим, что производитель не отправляет сообщения напрямую в сообщение.

очередь. Разрешение этого нарушило бы абстракцию в модели AMQ. Это было бы похоже на разрешение электронной почты на

обходят таблицы маршрутизации MTA и поступают прямо в почтовый ящик. Это сделало бы невозможным вставить

промежуточная фильтрация и обработка, например, обнаружение спама.

Модель AMQ использует тот же принцип, что и система электронной почты: все сообщения отправляются в одну точку,

exchange или MTA, который проверяет сообщения на основе правил и информации, скрытых от

отправителя и направляет их в пункты выдачи, которые также скрыты от отправителя.

2.1.2.3 Что видит потребитель

Наша аналогия с электронной почтой начинает разрушаться, когда мы смотрим на потребителей. Почтовые клиенты пассивны - они

могут читать их почтовые ящики, но они не имеют никакого влияния на то, как эти почтовые ящики заполняются. AMQP

Потребитель также может быть пассивным, так же, как клиенты электронной почты. То есть, мы можем написать приложение, которое ожидает

конкретная очередь сообщений, которая будет готова и связана, и которая будет просто обрабатывать сообщения из этого сообщения

очередь.

Однако мы также разрешаем клиентским приложениям AMQP:

◆ создавать или уничтожать очереди сообщений;

◆ определить способ заполнения этих очередей сообщений, сделав привязки;

◆ выбирать различные обмены, которые могут полностью изменить семантику маршрутизации.

Это похоже на систему электронной почты, в которой можно по протоколу:

◆ создать новый почтовый ящик;

◆ сообщить MTA, что все сообщения с определенным полем заголовка должны быть скопированы в этот почтовый ящик;

◆ полностью изменить способ интерпретации почтовой системой адресов и других заголовков сообщений.

Мы видим, что AMQP больше похож на язык для проводки части вместе, чем система. Это часть нашего

цель - сделать поведение сервера программируемым через протокол.

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 14 из 39

---

**Стр. 15**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Общая архитектура

2.1.2.4 Автоматический режим

Для большинства интеграционных архитектур такой уровень сложности не требуется. Как и фотограф-любитель,

большинству пользователей AMQP нужен режим «наведи и снимай». AMQP обеспечивает это за счет использования двух

упрощающие концепции:

◆ обмен по умолчанию для производителей сообщений;

◆ привязка по умолчанию для очередей сообщений, которая выбирает сообщения на основе соответствия между ключом маршрутизации и

имя очереди сообщений.

Фактически, привязка по умолчанию позволяет производителю отправлять сообщения непосредственно в очередь сообщений при условии подходящей

авторитет - он имитирует простейшую схему адресации «отправить по назначению», которую люди ожидают от

традиционное промежуточное ПО.

Привязка по умолчанию не препятствует использованию очереди сообщений более изощренными способами. Это

тем не менее, позволяет использовать AMQP без необходимости понимать, как работают обмены и привязки.

2.1.3 Обмены

2.1.3.1 Типы обмена

Каждый реализует обмен типа определенного алгоритма маршрутизации. Есть целый ряд стандартного обмена

типов, описанных в главе «Функциональные характеристики», но есть два, которые особенно

важный:

◆ Тип **прямого** обмена, при котором используется ключ маршрутизации. Обмен по умолчанию - это прямой обмен.

◆ **темы** типа обмена, какие маршруты по шаблону маршрутизации.

Сервер создаст набор обменов, включая прямой обмен и обмен темами при запуске с хорошо-

известные имена и клиентские приложения могут зависеть от этого.

2.1.3.2 Жизненный цикл обмена

Каждый сервер AMQP предварительно создает несколько обменов (экземпляров). Эти обмены существуют, когда сервер

начинается и не могут быть уничтожены. AMQP приложение может также создавать свои собственные обмены. AMQP не

использовать метод «создать» как таковой, он использует напористый метод «объявления», что означает «создать, если нет,

в противном случае продолжайте ". Вероятно, что приложения будут создавать биржи для частного использования и уничтожать их.

когда их работа будет закончена. AMQP предоставляет метод уничтожения обменов, но в целом приложения это делают.

не делай этого. В наших примерах в этой главе мы будем предполагать, что все обмены создаются сервером.

при запуске. Мы не будем показывать приложение, объявляющее об обмене.

2.1.4 Очереди сообщений

2.1.4.1 Свойства очереди сообщений

Когда клиентское приложение создает очередь сообщений, оно может выбрать некоторые важные свойства:

◆ **имя** - если не указано иное, сервер выбирает имя и предоставляет его клиенту. Обычно, когда

приложения совместно используют очередь сообщений, они заранее согласовывают имя очереди сообщений, а когда

Приложению нужна очередь сообщений для своих собственных целей, она позволяет серверу указать имя.

◆ **эксклюзивный** - если установлен, очередь принадлежит только текущему подключению и удаляется при подключении

закрывается.

◆ **долговечный** - если установлено, очередь сообщений остается активной при перезапуске сервера. Он может проиграть

временные сообщения при перезапуске сервера.

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 15 из 39

---

**Стр.16**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Общая архитектура

2.1.4.2 Жизненные циклы очереди

Существует два основных жизненных цикла очереди сообщений:

◆ **Долговечные очереди сообщений** , которые используются многими потребителями и существуют независимо, т. Е.

они будут продолжать существовать и собирать сообщения независимо от того, есть ли у них потребители.

◆ **Временные очереди сообщений,** которые являются частными для одного потребителя и привязаны к этому потребителю. Когда

потребитель отключается, очередь сообщений удаляется.

Есть несколько вариантов этого, например, **общие очереди сообщений** , которые удаляются, когда последний из многих

потребители отключаются. На этой схеме показано, как создаются и удаляются временные очереди сообщений:

Сообщение

Очередь

+ ------- +

Объявить + ------- + Очередь сообщений создана

--------> + ------- +

+ ------------- +

+ ------- +

| Потребитель | Потреблять

| приложение | -------->

+ ------------- +

\

/

Отмена + \\ ---- / *

--------> + - \\ // - + Очередь сообщений удалена

+ - // \\ - +

+ // ---- \ *

/

\

2.1.5 Привязки

Привязка - это связь между обменом и очередью сообщений, которая сообщает обмену, как

маршрутизировать сообщения. Привязки создаются из команд клиентского приложения (владеющего и

используя очередь сообщений) к обмену. Мы можем выразить команду привязки в псевдокоде следующим образом:

Queue.Bind <очередь> TO <обмен> ГДЕ <условие>

Давайте рассмотрим три типичных варианта использования: общие очереди, частные очереди ответов и подписки на публикацию.

2.1.5.1 Создание общей очереди

Общие очереди классический промежуточный слой «точка-точка очередь». В AMQP можно использовать по умолчанию

обмен и привязка по умолчанию. Предположим, наша очередь сообщений называется app.svc01. Вот псевдо-

код для создания общей очереди:

Queue.Declare

queue = app.svc01

У нас может быть много потребителей в этой общей очереди. Чтобы использовать из общей очереди, каждый потребитель

Является ли это:

Basic.Consume

queue = app.svc01

Чтобы опубликовать в общей очереди, каждый производитель отправляет сообщение в обмен по умолчанию:

Basic.Publish

ключ-маршрутизация = app.svc01

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 16 из 39

---

**Стр.17**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Общая архитектура

2.1.5.2 Создание очереди ответов

Очереди ответов обычно временные, с именами, назначаемыми сервером. Они также обычно частные, т.е. читаются

одним потребителем. Помимо этих особенностей, очереди ответов используют те же критерии соответствия, что и

стандартные очереди, поэтому мы также можем использовать обмен по умолчанию.

Вот псевдокод для создания очереди ответов, где S: указывает ответ сервера:

Queue.Declare

очередь = <пусто>

эксклюзивный = ИСТИНА

S: Очередь.Declare-Ok

очередь = tmp.1

Чтобы опубликовать в очереди ответов, производитель отправляет сообщение в обмен по умолчанию:

Basic.Publish

exchange = <пустой>

ключ маршрутизации = tmp.1

Одним из стандартных свойств сообщения является Reply-To, который разработан специально для переноса имени.

очередей ответов.

2.1.5.3 Создание очереди подписки на публикацию

В классическом промежуточном программном обеспечении термин «подписка» расплывчат и относится как минимум к двум различным концепциям:

критериев, соответствующих сообщениям, и временной очереди, содержащей совпадающие сообщения. AMQP отделяет

работа в привязках и очередях сообщений. Не существует сущности AMQP под названием «подписка».

Согласимся, что подписка pub-sub:

◆ хранит сообщения для одного потребителя (или в некоторых случаях для нескольких потребителей);

◆ собирает сообщения из нескольких источников с помощью набора привязок, соответствующих темам, полям сообщений или

контент по-разному.

Ключевое различие между очередью подписки и именованной очередью или очередью ответов заключается в том, что очередь подписки

имя не имеет значения для целей маршрутизации, и маршрутизация выполняется на основе абстрактных критериев соответствия, а не

чем соответствие 1 к 1 поля ключа маршрутизации.

Давайте возьмем общую модель pub-sub «тематических деревьев» и реализуем ее. Нужен тип обмена

возможность сопоставления в дереве тем. В AMQP это тип обмена «тема». Обмен темами

спички диких карт, как «STOCK.USD. *» против маршрутизации ключевых ценностей, как «STOCK.USD.NYSE».

Мы не можем использовать обмен по умолчанию или связывание, потому что они не делают маршрутизацию тема стиля. Таким образом, мы должны

явно создать привязку. Вот псевдокод для создания и привязки подписки pub-sub

очередь:

Queue.Declare

очередь = <пусто>

эксклюзивный = ИСТИНА

S: Очередь.Declare-Ok

очередь = tmp.2

Queue.Bind

очередь = tmp.2

К обмену = amq.topic

ГДЕ routing-key = STOCK.USD. *

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 17 из 39

---

**Стр.18**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Общая архитектура

Чтобы использовать из очереди подписки, потребитель делает следующее:

Basic.Consume

очередь = tmp.2

При публикации сообщения продюсер делает примерно следующее:

Basic.Publish

exchange = amq.topic

ключ-маршрутизация = STOCK.USD.ACME

Обмен темами обрабатывает входящий ключ маршрутизации ("STOCK.USD.ACME") с его таблицей привязки,

и находит одно совпадение для tmp.2. Затем он направляет сообщение в эту очередь подписки.

**2.2 Архитектура команд AMQP**

В этом разделе объясняется, как приложение общается с сервером.

2.2.1 Команды протокола (классы и методы)

Промежуточное ПО является сложным, и наша задача при разработке структуры протокола состояла в том, чтобы обуздать эту сложность.

Наш подход заключался в моделировании традиционного API на основе классов, содержащих методы, и в определении

методы, чтобы делать ровно одну вещь, и делать это хорошо. Это приводит к большому набору команд, но тот, который

относительно легко понять.

Команды AMQP сгруппированы в классы. Каждый класс охватывает определенный функциональный домен. Некоторые

классы являются необязательными - каждый одноранговый узел реализует классы, которые ему необходимо поддерживать.

Есть два различных диалога методов:

◆ Синхронный запрос-ответ, при котором один одноранговый узел отправляет запрос, а другой одноранговый узел отправляет ответ.

Методы синхронного запроса и ответа используются для функций, не критичных для производительности.

◆ Асинхронное уведомление, при котором один партнер отправляет метод, но не ожидает ответа. Асинхронный

методы используются там, где производительность критична.

Чтобы упростить обработку метода, мы определяем отдельные ответы для каждого синхронного запроса. То есть нет

используется в качестве ответа на два разных запроса. Это означает, что одноранговый узел, отправляющий синхронный

request, может принимать и обрабатывать входящие методы до получения одного из действительных синхронных ответов. Этот

отличает AMQP от более традиционных протоколов RPC.

Метод формально определяется как синхронный запрос, синхронный ответ (на конкретный запрос) или

асинхронный. Наконец, каждый метод формально определяется как клиентский (т. Е. От сервера к клиенту) или как серверный.

сторона (от клиента к серверу).

2.2.2 Сопоставление AMQP с API промежуточного программного обеспечения

Мы разработали AMQP для сопоставления с API промежуточного программного обеспечения. Это отображение имеет некоторый интеллект (не

все методы и не все аргументы имеют смысл для приложения), но он также является механическим (учитывая некоторые

правила, все методы могут быть отображены без ручного вмешательства).

Преимущества этого заключаются в том, что изучив семантику AMQP (классы, описанные в этом

раздел), разработчики найдут ту же семантику, предоставляемую в любой среде, которую они используют.

Например, вот пример метода Queue.Declare:

Queue.Declare

queue = my.queue

auto-delete = ИСТИНА

эксклюзивный = ЛОЖЬ

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 18 из 39

---

**Стр.19**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Общая архитектура

Его можно отлить как каркас уровня проводов:

+ -------- + --------- + ---------- + ----------- + ------- ---- +

| Очередь | Объявить | my.queue | 1 | 0 |

+ -------- + --------- + ---------- + ----------- + ------- ---- +

имя метода класса автоудаление эксклюзивное

Или как API более высокого уровня:

queue_declare (сеанс, "my.queue", ИСТИНА, ЛОЖЬ);

Логика псевдокода для отображения асинхронного метода:

отправить метод на сервер

Логика псевдокода для отображения синхронного метода:

отправить метод запроса на сервер

повторить

ждать ответа от сервера

если ответ - асинхронный метод

Метод процесса (обычно, доставлен или возвращен содержание)

еще

утверждать, что метод является действительным ответом на запрос

выход повторить

конец, если

конец-повтор

Стоит отметить, что для большинства приложений промежуточное ПО может быть полностью скрыто в техническом

Уровни, и то, что фактически используемый API, имеет меньшее значение, чем тот факт, что промежуточное программное обеспечение является надежным и функциональным.

2.2.3 Нет подтверждений

Болтливый протокол медленный. Мы активно используем асинхронизм в тех случаях, когда производительность является проблемой. Этот

обычно это место, где мы отправляем контент от одного партнера к другому. Мы отправляем способы как можно быстрее,

не дожидаясь подтверждения. В случае необходимости, мы реализуем оконные и дросселирование на более высоком

уровень, например, на уровне потребителя.

Мы можем отказаться от подтверждений, потому что мы применяем модель утверждений для всех действий. Либо они

успешно, или у нас есть исключение, которое закрывает канал или соединение.

В AMQP нет подтверждений. Успех молчит, и неудачи шумно. Когда приложениям нужны

явное отслеживание успехов и неудач, они должны использовать транзакции.

2.2.4 Класс подключения

AMQP - это подключенный протокол. Соединение рассчитано на длительное время и может передавать несколько

каналы. Жизненный цикл подключения таков:

◆ Клиент открывает соединение TCP / IP с сервером и отправляет заголовок протокола. Это единственные данные

клиент отправляет то, что не отформатировано как метод.

◆ Сервер отвечает своей версией протокола и другими свойствами, включая список безопасности

механизмы, которые он поддерживает (метод Start).

◆ Клиент выбирает механизм безопасности (Start-Ok).

◆ Сервер запускает процесс аутентификации, который использует модель запрос-ответ SASL. Он отправляет

клиент вызов (Secure).

◆ Клиент отправляет ответ аутентификации (Secure-Ok). Например, используя "простой" механизм,

ответ состоит из имени пользователя и пароля.

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 19 из 39

---

**Стр.20**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Общая архитектура

◆ Сервер повторяет запрос (Secure) или переходит к согласованию, отправляя набор параметров, таких как

максимальный размер кадра (Tune).

◆ Клиент принимает или понижает эти параметры (Tune-Ok).

◆ Клиент формально открывает соединение и выбирает виртуальный хост (Открыть).

◆ Сервер подтверждает, что виртуальный хост является допустимым выбором (Open-Ok).

◆ Теперь клиент использует соединение по своему усмотрению.

◆ Один партнер (клиент или сервер) завершает соединение (Close).

◆ Другой партнер пожимает рукой конец соединения (Close-Ok).

◆ Сервер и клиент закрывают свое сокетное соединение.

Нет никакого "рукопожатия" при ошибках на соединениях, которые не полностью открыты. После успешного протокола

согласование заголовка, которое подробно определено позже, и перед отправкой или получением Open или Open-Ok,

одноранговый узел, обнаруживший ошибку, ДОЛЖЕН закрыть сокет без отправки каких-либо дополнительных данных.

2.2.5 Класс канала

AMQP - это многоканальный протокол. Каналы обеспечивают способ мультиплексирования тяжеловесного TCP / IP.

соединение в несколько легких соединений. Это делает протокол более «дружественным к брандмауэрам», поскольку

использование порта предсказуемо. Это также означает, что формирование трафика и другие функции QoS в сети могут быть легко

заняты.

Каналы независимы друг от друга и могут выполнять разные функции одновременно с другими.

каналы, доступная полоса пропускания распределяется между одновременными действиями.

Ожидается и поощряется, что многопоточные клиентские приложения могут часто использовать «канал на поток».

модель как удобство программирования. Однако открытие нескольких подключений к одному или нескольким AMQP

серверы от одного клиента также вполне приемлемы. Жизненный цикл канала таков:

1. Клиент открывает новый канал (Открыть).

2. Сервер подтверждает, что новый канал готов (Open-Ok).

3. Клиент и сервер используют канал по своему усмотрению.

4. Один партнер (клиент или сервер) закрывает канал (Close).

5. Другой партнер пожимает руку закрытию канала (Close-Ok).

2.2.6 Обменный класс

Класс обмена позволяет приложению управлять обменами на сервере. Этот класс позволяет приложению

сценарий собственной проводки (вместо того, чтобы полагаться на какой-либо интерфейс конфигурации). Примечание. Большинство приложений не

требуется такой уровень сложности, а унаследованное промежуточное ПО вряд ли сможет поддерживать эту семантику.

Жизненный цикл биржи:

1. Клиент просит сервер убедиться, что обмен существует (Объявить). Клиент может уточнить это,

«создать биржу, если она не существует», или «предупредить, но не создавайте, если она не существует».

2. Клиент публикует сообщения для обмена.

3. Клиент может выбрать удаление обмена (Удалить).

2.2.7 Класс очереди

Класс очереди позволяет приложению управлять очередями сообщений на сервере. Это основной шаг почти во всех

приложения, которые потребляют сообщения, по крайней мере, чтобы убедиться, что ожидаемая очередь сообщений действительно присутствует.

Жизненный цикл устойчивой очереди сообщений довольно прост:

1. Клиент утверждает, что очередь сообщений существует (объявить с «пассивным» аргументом).

2. Сервер подтверждает, что очередь сообщений существует (Declare-Ok).

3. Клиент читает сообщения из очереди сообщений.

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 20 из 39

---

**Стр.21**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Общая архитектура

Жизненный цикл временной очереди сообщений более интересен:

1. Клиент создает очередь сообщений (объявляется, часто без имени очереди сообщений, чтобы сервер

присвоить имя). Сервер подтверждает (Declare-Ok).

2. Клиент запускает потребителя в очереди сообщений. Определяется точная функциональность потребителя.

Базовым классом.

3. Клиент аннулирует потребителя либо явно, либо путем закрытия канала и / или соединения.

4. Когда последний получатель исчезает из очереди сообщений и после вежливого тайм-аута, сервер

удаляет очередь сообщений.

AMQP реализует механизм доставки для подписок на темы в виде очередей сообщений. Это позволяет

интересные структуры, в которых нагрузка подписки может быть сбалансирована среди пула взаимодействующих подписчиков

Приложения.

Жизненный цикл подписки включает дополнительный этап привязки:

1. Клиент создает очередь сообщений (Declare), а сервер подтверждает (Declare-Ok).

2. Клиент привязывает очередь сообщений к обмену темами (Bind), и сервер подтверждает (Bind-Ok).

3. Клиент использует очередь сообщений, как в предыдущих примерах.

2.2.8 Базовый класс

Класс Basic реализует возможности обмена сообщениями, описанные в этой спецификации. Он поддерживает эти

основная семантика:

◆ Отправка сообщений от клиента к серверу, которая происходит асинхронно (публикация)

◆ Запуск и остановка потребителей (Потребление, Отмена)

◆ Отправка сообщений с сервера клиенту, которая происходит асинхронно (доставка, возврат)

◆ Подтверждение сообщений (Ack, Reject)

◆ Синхронное удаление сообщений из очереди сообщений (Get).

2.2.9 Класс транзакции

AMQP поддерживает два типа транзакций:

1. Автоматические транзакции, в которых каждое опубликованное сообщение и подтверждение обрабатываются как

автономная сделка.

2. Локальные транзакции сервера, в которых сервер буферизует опубликованные сообщения и подтверждения.

и зафиксируйте их по запросу клиента.

Класс Transaction («tx») предоставляет приложениям доступ ко второму типу, а именно к серверным транзакциям. В

семантика этого класса:

1. Приложение запрашивает серверные транзакции в каждом канале, где оно хочет эти транзакции (Выбрать).

2. Приложение работает (Опубликовать, Подтвердить).

3. Приложение фиксирует или откатывает работу (фиксация, откат).

4. Приложение работает до бесконечности.

Транзакции охватывают опубликованное содержание и подтверждения, а _не_ доставки. Таким образом, откат не

повторно поставить в очередь или повторно доставить любые сообщения, и клиент имеет право подтвердить эти сообщения в следующих

сделка.

**2.3 Транспортная архитектура AMQP**

В этом разделе объясняется, как команды отображаются в протоколе проводного уровня.

2.3.1 Общее описание

AMQP - это бинарный протокол. Информация организована в различные типы «фреймов». Рамки несут

методы протокола и другая информация. Все кадры имеют одинаковый общий формат: заголовок кадра, полезная нагрузка,

и конец рамы. Формат полезной нагрузки кадра зависит от типа кадра.

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 21 из 39

---

**Стр. 22**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Общая архитектура

Мы предполагаем наличие надежного сетевого транспортного уровня, ориентированного на потоки (TCP / IP или аналогичный).

Внутри одного сокетного соединения может быть несколько независимых потоков управления, называемых «каналами».

Каждый кадр пронумерован номером канала. Перемежая свои кадры, разные каналы разделяют

связь. Для любого данного канала кадры выполняются в строгой последовательности, которая может использоваться для управления протоколом.

парсер (обычно конечный автомат).

Мы создаем фреймы, используя небольшой набор типов данных, таких как биты, целые числа, строки и таблицы полей. Рамка

поля плотно упакованы, что не делает их медленными или сложными для анализа. Относительно просто создать

слой кадрирования механически из спецификаций протокола.

Форматирование на уровне проводов спроектировано так, чтобы быть масштабируемым и достаточно универсальным, чтобы его можно было использовать для произвольных высокоуровневых

протоколы (не только AMQP). Мы предполагаем, что AMQP будет расширяться, улучшаться и иным образом изменяться

time и формат проводного уровня будут поддерживать это.

2.3.2 Типы данных

Типы данных AMQP используются при формировании методов и являются:

◆ Целые числа (от 1 до 8 октетов), используемые для представления размеров, количества, пределов и т. Д. Целые числа всегда

без знака и может быть невыровненным в пределах кадра.

◆ Биты, используемые для представления значений включения / выключения. Биты упаковываются в октеты.

◆ Короткие строки, используемые для хранения свойств короткого текста. Короткие строки ограничены 255 октетами и могут быть

анализируется без риска переполнения буфера.

◆ Длинные строки, используемые для хранения фрагментов двоичных данных.

◆ Таблицы полей, содержащие пары имя-значение. Значения поля набираются в виде строк, целых чисел и т. Д.

2.3.3 Согласование протокола

Клиент и сервер AMQP согласовывают протокол. Это означает, что когда клиент подключается, сервер

предлагает определенные варианты, которые клиент может принять или изменить. Когда оба партнера согласны с результатом,

соединение идет впереди. Переговоры - полезный метод, потому что он позволяет нам утверждать предположения и

предварительные условия.

В AMQP мы согласовываем ряд конкретных аспектов протокола:

◆ Фактический протокол и версия. Сервер МОЖЕТ размещать несколько протоколов на одном и том же порте.

◆ Аргументы шифрования и аутентификация обеих сторон. Это часть функционального слоя,

объяснено ранее.

◆ Максимальный размер кадра, количество каналов и другие рабочие ограничения.

Согласованные ограничения МОГУТ позволить обеим сторонам заранее выделить ключевые буферы, избегая взаимоблокировок. Каждый входящий

кадр либо подчиняется согласованным ограничениям и поэтому является "безопасным", либо превышает их, и в этом случае другая сторона ЯВЛЯЕТСЯ

неисправен и ДОЛЖЕН быть отключен. Это очень похоже на то, что «либо работает правильно, либо

вообще не работает »философия AMQP.

Оба партнера согласовывают пределы минимального согласованного значения следующим образом:

◆ Сервер ДОЛЖЕН сообщить клиенту, какие ограничения он предлагает.

◆ Клиент отвечает и МОЖЕТ уменьшить эти ограничения для своего соединения.

2.3.4 Разделение рамок

TCP / IP - это потоковый протокол, т.е. нет встроенного механизма для разграничения кадров. Существующие протоколы

решить эту проблему несколькими способами:

◆ Отправка одного кадра на каждое соединение. Это просто, но медленно.

◆ Добавление в поток разделителей кадров. Это просто, но медленно разбирается.

◆ Подсчет размера фреймов и отправка размера перед каждым фреймом. Это просто и быстро, и наши

выбор.

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 22 из 39

---

**Стр. 23**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Общая архитектура

2.3.5 Детали рамы

Все кадры состоят из заголовка (7 октетов), полезной нагрузки произвольного размера и октета конца кадра, который определяет

искаженные кадры:

0 1

3

7

размер + 7 размер + 8

+ ------ + --------- + ------------- + + ------------ + + --- -------- +

| тип | канал | размер | | полезная нагрузка | | конец кадра |

+ ------ + --------- + ------------- + + ------------ + + --- -------- +

октет короткий

длинный

октеты размера

октет

Чтобы прочитать фрейм, мы:

1. Прочтите заголовок и проверьте тип кадра и канал.

2. В зависимости от типа кадра мы читаем полезную нагрузку и обрабатываем ее.

3. Считайте октет конца кадра.

В реалистичных реализациях, где важна производительность, мы могли бы использовать «буферизацию с упреждающим чтением» или

«Сбор чтения», чтобы избежать выполнения трех отдельных системных вызовов для чтения кадра.

2.3.5.1 Фреймы метода

Кадры методов несут команды протокола высокого уровня (которые мы называем «методами»). Фрейм с одним методом

несет одну команду. Полезная нагрузка кадра метода имеет следующий формат:

0

2

4

+ ---------- + ----------- + -------------- - -

| идентификатор класса | идентификатор метода | аргументы ...

+ ---------- + ----------- + -------------- - -

коротко коротко ...

Чтобы обработать фрейм метода, мы:

1. Прочтите полезную нагрузку кадра метода.

2. Распаковать в конструкцию. Данный метод всегда имеет одинаковую структуру, поэтому мы можем распаковать

метод быстро.

3. Убедитесь, что метод разрешен в текущем контексте.

4. Убедитесь, что аргументы метода действительны.

5. Выполните метод.

Тела кадра метода состоят из списка полей данных AMQP (битов, целых чисел, строк и строк).

таблицы). Код маршаллинга тривиально генерируется непосредственно из спецификаций протокола и может быть

очень быстро.

2.3.5.2 Фреймы содержимого

Контент - это данные приложения, которые мы передаем от клиента к клиенту через сервер AMQP. Контент примерно

говоря, набор свойств плюс часть двоичных данных. Набор разрешенных свойств определяется Базовым

class, и они образуют «фрейм заголовка содержимого». Данные могут быть любого размера и МОГУТ быть разбиты на

несколько (или много) фрагментов, каждый из которых образует «фрейм тела содержимого».

Глядя на кадры для определенного канала, когда они проходят по проводу, мы можем увидеть что-то вроде этого:

[метод]

[метод] [заголовок] [тело] [тело

[метод]

...

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 23 из 39

---

**Стр. 24**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Общая архитектура

Некоторые методы (такие как Basic.Publish, Basic.Deliver и т. Д.) Формально определены как переносящие контент.

Когда одноранговый узел отправляет такой кадр метода, он всегда следует за ним с заголовком содержимого и нулем или более

фреймы тела содержимого.

Фрейм заголовка содержимого имеет следующий формат:

0

2

4

12

14

+ ---------- + -------- + ----------- + ---------------- + ------------- - -

| идентификатор класса | вес | размер тела | флаги собственности | список недвижимости ...

+ ---------- + -------- + ----------- + ---------------- + ------------- - -

короткие короткие длинные длинные

короткая

остаток ...

Мы помещаем тело контента в отдельные фреймы (а не включаем его в метод), чтобы AMQP мог

поддерживают методы «нулевого копирования», при которых контент никогда не упорядочивается и не кодируется. Размещаем контент

свойства в их собственном фрейме, чтобы получатели могли выборочно отбрасывать содержимое, которое они не хотят обрабатывать.

2.3.5.3 Кадры сердцебиения

Heartbeating - это метод, предназначенный для отмены одной из функций TCP / IP, а именно его способности восстанавливаться после

разорванное физическое соединение, закрытие только после довольно долгого перерыва. В некоторых сценариях нам нужно знать

очень быстро, если одноранговый узел отключен или не отвечает по другим причинам (например, зацикливается). С сердцем-

биение может быть выполнено на низком уровне, мы реализуем это как специальный тип кадра, которым одноранговые узлы обмениваются на

транспортный уровень, а не как метод класса.

2.3.6 Обработка ошибок

AMQP использует исключения для обработки ошибок. Любая операционная ошибка (очередь сообщений не найдена, недостаточно

права доступа и т. д.) приводит к исключению канала. Любая структурная ошибка (недопустимый аргумент, неправильная последовательность

методы и т. д.) приводит к исключению подключения. Исключение закрывает канал или соединение, и

возвращает код ответа и текст ответа клиентскому приложению. Мы используем 3-значный код ответа плюс текстовый ответ

текстовая схема, которая используется в HTTP и многих других протоколах.

2.3.7 Закрытие каналов и подключений

Соединение или канал считается «открытым» для клиента, когда он послал Open, и для сервера, когда

он отправил Open-Ok. С этого момента партнер, желающий закрыть канал или соединение, ДОЛЖЕН

сделайте это, используя протокол рукопожатия, описанный здесь.

Закрытие канала или соединения по любой причине - нормальной или исключительной - должно выполняться осторожно. Резкий

закрытие не всегда обнаруживается быстро, и после исключения мы можем потерять коды ответа об ошибке.

Правильный дизайн - встряхнуть все застежки, чтобы мы закрывались только после того, как убедимся, что другая сторона

в курсе ситуации.

Когда одноранговый узел решает закрыть канал или соединение, он отправляет метод Close. Принимающий партнер ДОЛЖЕН

ответить на Close с Close-Ok, и затем обе стороны могут закрыть свой канал или соединение. Обратите внимание, что

если одноранговые узлы игнорируют Close, может возникнуть взаимоблокировка, когда оба одноранговых узла одновременно отправят Close.

**2.4 Клиентская архитектура AMQP**

Можно читать и записывать кадры AMQP непосредственно из приложения, но это было бы плохим дизайном.

Даже простейший диалог AMQP намного сложнее, чем, скажем, HTTP и разработчики приложений.

не нужно понимать такие вещи, как двоичные форматы кадрирования, чтобы отправить сообщение

очередь сообщений. Рекомендуемая клиентская архитектура AMQP состоит из нескольких уровней абстракции:

1. **Обрамляющий слой** . Этот уровень использует методы протокола AMQP в некотором языковом формате.

(структуры, классы и т. д.) и сериализует их как фреймы уровня проводов. Обрамляющий слой может быть

механически генерируется из спецификаций AMQP (которые определены при моделировании протокола

язык, реализованный в XML и специально разработанный для AMQP).

2. **Уровень диспетчера соединений** . Этот уровень считывает и записывает кадры AMQP и управляет общим

логика подключения и сеанса. В этом слое мы можем инкапсулировать полную логику открытия соединения.

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 24 из 39

---

**Стр.25**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Общая архитектура

сеанс, обработка ошибок, передача и прием контента и т. д. Большие части этого слоя могут

производиться автоматически на основе спецификаций AMQP. Например, спецификации определяют

какие методы несут контент, поэтому логика «отправить метод, а затем, необязательно, отправить контент» может быть

производится механическим способом.

3. Уровень **API** . Этот уровень предоставляет конкретный API для работы приложений. Уровень API может

отражать некоторый существующий стандарт или может предоставлять высокоуровневые методы AMQP, делая сопоставление как

описано ранее в этом разделе. Методы AMQP предназначены для упрощения этого сопоставления

и полезно. Уровень API может сам состоять из нескольких уровней, например, API более высокого уровня.

построен на основе API метода AMQP.

Кроме того, обычно существует какой-то уровень ввода-вывода, который может быть очень простым (синхронный сокет читает

и пишет) или сложный (полностью асинхронный многопоточный ввод-вывод). На этой диаграмме показан общий

рекомендуемая архитектура:

+ ------------------------ +

| заявка

|

+ ----------- + ------------ +

|

+ ------------------------ +

+ --- | Уровень API

| ---- Уровень клиентского API ----- +

| + ----------- + ------------ +

|

|

|

|

| + ------------------------ + + --------------- + |

| | Диспетчер подключений + ---- + Уровень кадра | |

| + ----------- + ------------ + + --------------- + |

|

|

|

| + ------------------------ +

|

+ --- | Уровень асинхронного ввода-вывода | ------------------------- +

+ ----------- + ------------ +

|

-------

- - - - Сеть - - - -

-------

В этом документе, когда мы говорим о «клиентском API», мы имеем в виду все уровни ниже приложения (ввод-вывод,

кадрирование, диспетчер соединений и уровни API. Обычно мы говорим о «клиентском API» и «

приложение »как две отдельные вещи, где приложение использует клиентский API для взаимодействия с промежуточным программным обеспечением

сервер.

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 25 из 39

---

**Стр. 26**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Функциональная спецификация

3 Функциональные характеристики

**3.1 Функциональные характеристики сервера**

3.1.1 Сообщения и контент

Сообщение - это элементарная единица обработки промежуточного программного обеспечения маршрутизации и системы очередей. Сообщения несут

содержимое, которое состоит из заголовка содержимого, содержащего набор свойств, и тела содержимого, содержащего

непрозрачный блок двоичных данных.

Сообщение может соответствовать множеству различных объектов приложения:

◆ Сообщение на уровне приложения.

◆ файл для передачи

◆ Один кадр потока данных и т. Д.

Сообщения могут быть постоянными. Постоянное сообщение надежно хранится на диске и гарантированно будет доставлено.

даже в случае серьезного сбоя сети, сбоя сервера, переполнения и т. д.

Сообщения могут иметь уровень приоритета. Сообщение с высоким приоритетом отправляется перед сообщениями с более низким приоритетом.

ожидание в той же очереди сообщений. Когда сообщения должны быть отброшены, чтобы поддерживать определенный

При уровне качества обслуживания сервер сначала отбрасывает сообщения с низким приоритетом.

Сервер НЕ ДОЛЖЕН изменять тела содержимого сообщений, которые он получает и передает потребителю.

Приложения. Сервер МОЖЕТ добавлять информацию в заголовки контента, но НЕ ДОЛЖЕН удалять или изменять

существующая информация.

3.1.2 Виртуальные хосты

Виртуальный хост - это раздел данных на сервере, это удобство администрирования, которое докажет

полезно для тех, кто хочет предоставить AMQP как услугу в общей инфраструктуре.

Виртуальный хост включает собственное пространство имен, набор обменов, очереди сообщений и все связанные

объекты. Каждое соединение ДОЛЖНО быть связано с одним виртуальным хостом.

Клиент выбирает виртуальный хост в методе Connection.Open после аутентификации. Это означает, что

Схема аутентификации сервера используется всеми виртуальными хостами на этом сервере. Однако

Используемая схема авторизации МОЖЕТ быть уникальной для каждого виртуального хоста. Это предназначено для использования в общих

хостинговая инфраструктура. Администраторы, которым нужны разные схемы аутентификации для каждого виртуального хоста.

следует использовать отдельные серверы.

Все каналы в рамках соединения работают с одним и тем же виртуальным хостом. Нет возможности общаться с

другой виртуальный хост в том же соединении, и нет никакого способа переключиться на другой виртуальный хост

не разрывая соединение и начиная заново.

Протокол не предлагает механизмов для создания или настройки виртуальных хостов - это делается в неопределенном

внутри сервера и полностью зависит от реализации.

3.1.3 Обмены

Обмен - это агент маршрутизации сообщений на виртуальном хосте. Экземпляр обмена (который мы обычно

называют "обмен") принимает сообщения и информацию о маршрутизации - в основном ключ маршрутизации - и либо

передает сообщения в очереди сообщений или во внутренние службы. Биржи именуются на виртуальном хосте

основание.

Приложения могут свободно создавать, обмениваться, использовать и уничтожать экземпляры обмена в пределах своих

орган власти.

Биржи могут быть долговременными, временными или автоматически удаляемыми. Долговременные обмены действуют до тех пор, пока они не будут удалены.

Временные обмены продолжаются до выключения сервера. Автоматически удаленные биржи длятся до тех пор, пока не будут отменены.

дольше использовал.

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 26 из 39

---

**Стр. 27**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Функциональная спецификация

Сервер предоставляет определенный набор типов обмена. Каждый тип обмена реализует определенное соответствие

и алгоритм, как определено в следующем разделе. AMQP требует небольшого количества типов обмена и

рекомендует еще. Кроме того, каждая реализация сервера может добавлять свои собственные типы обмена.

Обмен может направлять одно сообщение во многие очереди сообщений параллельно. Это создает несколько

экземпляры сообщения, которые потребляются независимо.

3.1.3.1 Тип прямого обмена

Тип прямого обмена работает следующим образом:

1. Очередь сообщений связывается с обменом с помощью ключа маршрутизации K.

2. Издатель отправляет обмену сообщение с ключом маршрутизации R.

3. Сообщение передается в очередь сообщений, если K = R.

Сервер ДОЛЖЕН реализовать тип прямого обмена и ДОЛЖЕН предварительно объявить в каждом виртуальном хосте на

минимум два прямых обмена: один с именем **amq.direct** и один **без публичного имени,** который используется по умолчанию

обмен на методы публикации.

Обратите внимание, что очереди сообщений могут связываться с использованием любого допустимого значения ключа маршрутизации, но чаще всего очереди сообщений

привязать, используя собственное имя в качестве ключа маршрутизации.

В частности, все очереди сообщений ДОЛЖНЫ БЫТЬ автоматически привязаны к безымянному обмену с помощью

имя очереди сообщений как ключ маршрутизации.

3.1.3.2 Тип обмена Fanout

Тип обмена разветвлением работает следующим образом:

1. Очередь сообщений связывается с обменом без аргументов.

2. Издатель отправляет обмену сообщение.

3. Сообщение безоговорочно передается в очередь сообщений.

Обмен разветвлениями несложно спроектировать и реализовать. Этот тип обмена и заранее объявленный обмен

называется **amq.fanout** , являются обязательными.

3.1.3.3 Тип обмена темами

Тип обмена темами работает следующим образом:

1. Очередь сообщений связывается с обменом с использованием шаблона маршрутизации P.

2. Издатель отправляет обмену сообщение с ключом маршрутизации R.

3. Сообщение передается в очередь сообщений, если R соответствует P.

Ключ маршрутизации, используемый для обмена темами, ДОЛЖЕН состоять из нуля или более слов, разделенных точками. Каждый

Слово может содержать буквы AZ и az и цифры 0-9.

Шаблон маршрутизации следует тем же правилам, что и ключ маршрутизации, с добавлением, что * соответствует одному

слово, а # соответствует нулю или более слов. Таким образом, шаблон маршрутизации * .stock. # Соответствует ключам маршрутизации.

usd.stock и eur.stock.db, но не stock.nasdaq.

Один из предлагаемых вариантов обмена темами - хранить набор всех известных ключей маршрутизации и обновлять его.

когда издатели используют новые ключи маршрутизации. Можно определить все привязки для данного ключа маршрутизации и

чтобы быстро найти очереди сообщений для сообщения. Этот тип обмена не является обязательным.

Серверу СЛЕДУЕТ реализовать тип обмена темами, и в этом случае сервер ДОЛЖЕН предварительно объявить

внутри каждого виртуального хоста должен быть хотя бы один обмен **темами с** именем **amq.topic** .

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 27 из 39

---

**Стр.28**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Функциональная спецификация

3.1.3.4 Тип обмена заголовками

Тип обмена заголовками работает следующим образом:

1. Очередь сообщений привязана к обмену с таблицей аргументов, содержащей заголовки, которые должны быть

соответствует этой привязке и, при необходимости, значениям, которые они должны содержать. Ключ маршрутизации не используется.

2. Издатель отправляет сообщение на обмен, в котором свойство "заголовки" содержит таблицу

имена и ценности.

3. Сообщение передается в очередь, если свойство заголовков совпадает с аргументами, с которыми

очередь была связана.

Алгоритм сопоставления управляется специальным аргументом связывания, передаваемым как пара значений имени в

таблица аргументов. Имя этого аргумента - «x-match». Может принимать одно из двух значений, определяющих, как

остальные пары имя-значение в таблице обрабатываются во время сопоставления:

◆ "все" означает, что все остальные пары должны соответствовать свойству заголовков сообщения, чтобы это сообщение было

маршрутизируется (т.е. и соответствует И)

◆ 'any' означает, что сообщение должно быть перенаправлено, если какое-либо из полей в свойстве заголовков соответствует одному из

поля в таблице аргументов (то есть совпадение по ИЛИ)

Поле в аргументах привязки совпадает с полем в сообщении, если какое-либо поле в аргументах привязки имеет

нет значения и поле с таким же именем присутствует в заголовках сообщений или если поле в привязке

Аргументы имеют значение, и одноименное поле существует в заголовках сообщений и имеет такое же значение.

Любое поле, начинающееся с «x-», кроме «x-match», зарезервировано для использования в будущем и будет проигнорировано.

Серверу СЛЕДУЕТ реализовать тип обмена заголовками, и в этом случае сервер ДОЛЖЕН предварительно объявить

внутри каждого виртуального хоста обменивается по крайней мере один заголовок с именем **amq.match** .

3.1.3.5 Тип системного обмена

Тип обмена системы работает следующим образом:

1. Издатель отправляет обмену сообщение с ключом маршрутизации S.

2. Системный обмен передает это системной службе S.

Системные службы, начинающиеся с "amq." зарезервированы для использования AMQP. Все остальные имена могут использоваться свободно.

на серверных реализациях. Этот тип обмена не является обязательным.

3.1.3.6 Типы обмена, определяемые реализацией

Все ненормативные типы обмена ДОЛЖНЫ называться, начиная с «x-». Типы обмена, которые не запускаются

с «x-» зарезервированы для будущего использования в стандарте AMQP.

3.1.4 Очереди сообщений

Очередь сообщений - это именованный буфер FIFO, в котором хранятся сообщения от имени набора потребительских приложений.

Приложения могут свободно создавать, совместно использовать, использовать и уничтожать очереди сообщений в пределах своих полномочий.

Обратите внимание, что при наличии нескольких считывателей из очереди, клиентских транзакциях или использовании полей приоритета,

или использование селекторов сообщений, или оптимизации доставки, зависящей от реализации, очередь НЕ МОЖЕТ

демонстрируют истинные характеристики FIFO. Единственный способ гарантировать FIFO - это подключить только одного потребителя.

в очередь. В этих случаях очередь может быть описана как «слабый FIFO».

Очереди сообщений могут быть долговечными, временными или автоматически удаляемыми. Долговечные очереди сообщений существуют до тех пор, пока они не будут

удалено. Временные очереди сообщений существуют до выключения сервера. Автоматически удаленные очереди сообщений последней

пока они не перестанут использоваться.

Очереди сообщений хранят свои сообщения в памяти, на диске или в некоторой их комбинации. Очереди сообщений

именуются для каждого виртуального хоста.

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 28 из 39

---

**Стр.29**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Функциональная спецификация

Очереди сообщений содержат сообщения и распределяют их между одним или несколькими клиентами-потребителями. Сообщение

направленный в очередь сообщений никогда не отправляется более чем одному клиенту, если он не пересылается после сбоя или

отказ.

Одна очередь сообщений может содержать разные типы контента одновременно и независимо. То есть, если

Базовое содержимое и содержимое файла отправляются в одну и ту же очередь сообщений, они будут доставлены потребителю.

приложения самостоятельно по запросу.

3.1.5 Привязки

Привязка - это связь между очередью сообщений и обменом. Привязка указывает маршрутизацию

аргументы, которые сообщают обмену, какие сообщения должна получать очередь. Приложения создают и уничтожают

привязки по мере необходимости, чтобы направить поток сообщений в их очереди сообщений. Срок службы привязок

зависят от очередей сообщений, для которых они определены - когда очередь сообщений уничтожается, ее привязки

также уничтожен. Конкретная семантика метода Queue.Bind зависит от типа обмена.

3.1.6 Потребители

Мы используем термин «потребитель» для обозначения как клиентского приложения, так и объекта, который контролирует, как конкретное

клиентское приложение получает сообщения из очереди сообщений. Когда клиент «запускает потребителя», он создает

потребительский объект на сервере. Когда клиент "отменяет потребителя", он уничтожает объект потребителя в

сервер. Потребители принадлежат к одному клиентскому каналу и заставляют очередь сообщений отправлять сообщения

асинхронно с клиентом.

3.1.7 Качество обслуживания

Качество обслуживания определяет, насколько быстро отправляются сообщения. Качество обслуживания зависит от типа

распространяемый контент. Обычно для определения качества обслуживания используется концепция упреждающей выборки.

сколько сообщений или сколько октетов данных будет отправлено, прежде чем клиент подтвердит сообщение. В

цель состоит в том, чтобы отправить данные сообщения заранее, чтобы уменьшить задержку.

3.1.8 Благодарности

Подтверждение - это формальный сигнал от клиентского приложения к очереди сообщений о том, что у него есть

сообщение успешно обработано. Возможны две модели подтверждения:

1. _Автоматически_ , при котором сервер удаляет контент из очереди сообщений, как только он доставляет его в

приложение (методами Deliver или Get-Ok).

2. _Явный_ , при котором клиентское приложение должно отправлять метод Ack для каждого сообщения или пакета

сообщения, которые он обработал.

Клиентские уровни могут сами реализовывать явные подтверждения по-разному, например, как только

сообщение получено, или когда приложение указывает, что оно обработало его. Эти различия не

влияют на AMQP или совместимость.

3.1.9 Управление потоком

Управление потоком - это экстренная процедура, используемая для остановки потока сообщений от однорангового узла. Работает в

таким же образом между клиентом и сервером и реализуется командой Channel.Flow. Управление потоком

единственный механизм, который может остановить чрезмерно производящего издателя. Потребитель может использовать более элегантный

механизм окна предварительной выборки, если он использует подтверждения сообщений (что обычно означает использование

сделки).

3.1.10 Соглашения об именах

Эти соглашения регулируют именование объектов AMQP. Сервер и клиент ДОЛЖНЫ соблюдать эти

условности:

◆ Типы обмена, определяемые пользователем, ДОЛЖНЫ иметь префикс "x-"

◆ Стандартные экземпляры обмена имеют префикс amq.

◆ Стандартные системные службы имеют префикс amq.

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 29 из 39

---

**Стр.30**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Функциональная спецификация

◆ Стандартные очереди сообщений имеют префикс amq.

◆ Все остальные имена обмена, системных служб и очередей сообщений находятся в пространстве приложений.

**3.2 Спецификация команд AMQP (классы и методы)**

3.2.1 Пояснительные примечания

Методы AMQP могут определять конкретные минимальные значения (например, количество потребителей на сообщение

очередь) по причинам совместимости. Эти минимумы определены в описании каждого класса.

Соответствующим реализациям AMQP СЛЕДУЕТ реализовывать достаточно большие значения для таких полей,

Minima предназначена только для использования на наименее функциональных платформах.

В грамматиках используется это обозначение:

◆ «S:» указывает данные или метод, отправленные с сервера клиенту;

◆ «C:» указывает данные или метод, отправленные от клиента на сервер;

◆ + термин или + (...) выражение означает «1 или несколько экземпляров»;

◆ выражение * термин или * (...) означает «ноль или более экземпляров».

Мы определяем методы как:

◆ синхронный запрос («запрос синхронизации»). Отправляющему партнеру СЛЕДУЕТ дождаться определенного метода ответа,

но МОЖЕТ реализовать это асинхронно;

◆ синхронный ответ («синхронный ответ для XYZ»);

◆ асинхронный запрос или ответ («асинхронный»).

3.2.2 Сведения о классе и методе

Этот раздел предоставляется сгенерированным документом _**amqp-xml-spec.odt**_ .

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 30 из 39

---

**Стр.31**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Технические характеристики

4 Технические характеристики

**4.1 Номер порта, присвоенный IANA**

Стандартный номер порта AMQP был назначен IANA как **5672** как для TCP, так и для UDP. UDP

порт зарезервирован для использования в будущих реализациях многоадресной передачи.

**4.2 Формат уровня проводов AMQP**

4.2.1 Формальная грамматика протокола

Мы предоставляем полную грамматику AMQP (она предоставляется для справки, и вы можете найти ее подробнее)

интересно перейти к следующим разделам, в которых подробно описаны различные типы фреймов и их форматы):

amqp

= заголовок протокола * блок amqp

протокол-заголовок = буквальный-AMQP идентификатор-протокола версия-протокола

буквальный-AMQP

=% d65.77.81.80

; «AMQP»

идентификатор протокола

=% d0

; Должно быть 0

версия-протокола =% d0.9.1

; 0-9-1

метод

= метод-кадр [содержание]

метод-фрейм

=% d1 свойства кадра метод-полезная нагрузка конец кадра

frame-properties = размер полезной нагрузки канала

канал

= short-uint

; Ненулевой

размер полезной нагрузки

= long-uint

полезная нагрузка метода = идентификатор-класса идентификатор-метода * поле amqp

ID класса

=% x00.01-% xFF.FF

идентификатор метода

=% x00.01-% xFF.FF

amqp-поле

= БИТ / ОКТЕТ

/ короткий-uint / длинный-uint / длинный-длинный-uint

/ короткая строка / длинная строка

/ отметка времени

/ field-table

short-uint

= 2 * ОКТЕТ

long-uint

= 4 * ОКТЕТ

длинный-длинный-uint = 8 * OCTET

короткая строка

= ОКТЕТ * строковый символ

; длина + содержание

струнный символ

=% x01 ..% xFF

длинная струна

= long-uint * OCTET

; длина + содержание

отметка времени

= длинный-длинный-uint

; 64-битный POSIX

полевая таблица

= long-uint * пара значений поля

пара-значения-поля = имя-поля значение-поля

название поля

= короткая строка

значение поля

= 't' логическое

/ 'b' короткий-короткий-int

/ 'B' короткий-короткий-uint

/ 'U' короткое int

/ 'u' короткий-uint

/ 'I' длинное целое

/ 'я' долгое время-uint

/ 'L' длинный-длинный-int

/ 'l' длинный-длинный-uint

/ 'f' с плавающей точкой

/ 'd' двойной

/ Десятичное значение 'D'

/ 's' короткая строка

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 31 из 39

---

**Стр.32**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Технические характеристики

/ 'S' длинная строка

/ Массив полей 'A'

/ 'T' отметка времени

/ Поле-таблица 'F'

/ 'V'

; нет поля

логический

= ОКТЕТ

; 0 = ЛОЖЬ, иначе ИСТИНА

short-short-int = ОКТЕТ

short-short-uint = ОКТЕТ

короткий интервал

= 2 * ОКТЕТ

длинный интервал

= 4 * ОКТЕТ

длинный-длинный-int

= 8 * ОКТЕТ

плавать

= 4 * ОКТЕТ

; IEEE-754

двойной

= 8 * ОКТЕТ

; rfc1832 XDR двойной

десятичное значение

= масштабировать long-uint

шкала

= ОКТЕТ

; количество десятичных цифр

поле-массив

= длинное целое * значение поля; массив значений

конец рамы

=% xCE

содержание

=% d2 заголовок содержимого * тело содержимого

content-header = свойства-кадра заголовок-полезная нагрузка конец кадра

заголовок-полезная нагрузка = контент-класс вес-контент контент-размер тела

свойство-флаги список-свойств

контент-класс

= ОКТЕТ

содержание-вес =% x00

контент-размер-тела = длинный-длинный-uint

флаги свойств = 15 * BIT% b0 / 15 * BIT% b1 флаги свойств

список свойств

= * amqp-поле

Content-Body

=% d3 свойства-кадра body-payload конец кадра

полезная нагрузка кузова

= * ОКТЕТ

сердцебиение

=% d8% d0% d0 конец кадра

Мы используем расширенный синтаксис BNF, определенный в IETF RFC 2234. Таким образом,

◆ Название правила - это просто само название.

◆ Терминалы обозначаются одним или несколькими числовыми символами с базовой интерпретацией тех

символы, обозначенные как 'd' или 'x'.

◆ Правило может определять простую упорядоченную строку значений, перечисляя последовательность имен правил.

◆ Диапазон альтернативных числовых значений можно указать компактно, используя тире ("-") для обозначения

диапазон альтернативных значений.

◆ Элементы, заключенные в круглые скобки, рассматриваются как один элемент, содержимое которого строго упорядочено.

◆ Элементы, разделенные косой чертой ("/"), являются альтернативными.

◆ Оператор «*» перед элементом указывает на повторение. Полная форма: «<a> * <b> элемент»,

где <a> и <b> - необязательные десятичные значения, указывающие как минимум <a> и не более <b> вхождений

элемент.

◆ Правило формы: «<n> элемент» эквивалентно <n> * <n> элемент.

◆ Квадратные скобки заключают необязательную последовательность элементов.

4.2.2 Заголовок протокола

Клиент ДОЛЖЕН начать новое соединение, отправив заголовок протокола. Это 8-октетная последовательность:

+ --- + --- + --- + --- + --- + --- + --- + --- +

| 'A' | 'M' | 'Q' | 'P' | 0 | 0 | 9 | 1 |

+ --- + --- + --- + --- + --- + --- + --- + --- +

8 октетов

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 32 из 39

---

**Стр. 33**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Технические характеристики

Заголовок протокола состоит из заглавных букв «AMQP», за которыми следует константа% d0, затем:

1. Основная версия протокола, используемая в соответствии с разделом [1.4.2.](https://translate.googleusercontent.com/translate_f#9)

2. Дополнительная версия протокола, используемая в соответствии с п. [1.4.2.](https://translate.googleusercontent.com/translate_f#9)

3. Ревизия протокола, используемого в соответствии с п. [1.4.2.](https://translate.googleusercontent.com/translate_f#9)

Модель согласования протокола совместима с существующими протоколами, такими как HTTP, которые инициируют

соединение с постоянной текстовой строкой и с брандмауэрами, которые обнюхивают начало протокола, чтобы решить

какие правила к нему применить.

Клиент и сервер согласовывают протокол и версию следующим образом:

◆ Клиент открывает новое соединение сокета с сервером AMQP и отправляет заголовок протокола.

◆ Сервер принимает или отклоняет заголовок протокола. Если он отклоняет заголовок протокола, записывает действительный

заголовок протокола в сокет, а затем закрывает сокет.

◆ В противном случае он оставляет сокет открытым и соответствующим образом реализует протокол.

Примеры:

Клиент отправляет:

Сервер отвечает:

AMQP% d0.0.9.1

Connection.Start метод

AMQP% d0.1.0.0

AMQP% d0.0.9.1 <Закрыть соединение>

HTTP

AMQP% d0.0.9.1 <Закрыть соединение>

Рекомендации для исполнителей:

◆ Сервер МОЖЕТ принимать протоколы, отличные от AMQP, такие как HTTP.

◆ Если сервер не распознает первые 5 октетов данных в сокете или не поддерживает определенные

версия протокола, которую запрашивает клиент, он ДОЛЖЕН записать допустимый заголовок протокола в сокет, а затем сбросить

сокет (чтобы клиентское приложение получило данные), а затем закройте соединение сокета.

Сервер МОЖЕТ напечатать диагностическое сообщение для облегчения отладки.

◆ Клиент МОЖЕТ определить версию протокола сервера, пытаясь подключиться к самой высокой поддерживаемой версии.

версия и переподключение с более ранней версией, если она получает такую ​​информацию обратно с сервера.

◆ Клиенты и серверы, реализующие несколько версий AMQP, должны использовать все восемь октетов

Заголовок протокола для идентификации протокола.

4.2.3 Общий формат кадра

Все кадры начинаются с 7-октетного заголовка, состоящего из поля типа (октет), поля канала (короткое целое число) и

поле размера (длинное целое число):

0 1

3

7

размер + 7 размер + 8

+ ------ + --------- + --------- + + ------------- + + ------ ----- +

| тип | канал | размер | | полезная нагрузка | | конец кадра |

+ ------ + --------- + --------- + + ------------- + + ------ ----- +

октет короткий длинный

октеты 'size'

октет

AMQP определяет эти типы кадров:

◆ Тип = 1, «МЕТОД»: фрейм метода.

◆ Type = 2, «HEADER»: фрейм заголовка содержимого.

◆ Type = 3, "BODY": фрейм тела содержимого.

◆ Type = 4, «HEARTBEAT»: кадр сердцебиения.

Номер канала равен 0 для всех кадров, которые являются глобальными для соединения, и 1-65535 для кадров, которые

обратитесь к конкретным каналам.

Поле размера - это размер полезной нагрузки, исключая октет конца кадра. В то время как AMQP предполагает надежную

подключенный протокол, мы используем конец кадра для обнаружения ошибок кадрирования, вызванных неправильным клиентом или сервером

реализации.

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 33 из 39

---

**Стр. 34**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Технические характеристики

Рекомендации для исполнителей:

◆ Октет конца кадра ДОЛЖЕН быть шестнадцатеричным значением% xCE.

◆ Если одноранговый узел получает кадр с типом, который не является одним из этих определенных типов, он ДОЛЖЕН рассматривать это как

фатальная ошибка протокола и закрыть соединение, не отправляя никаких дополнительных данных

◆ Когда одноранговый узел читает фрейм, он ДОЛЖЕН проверить, что конец фрейма действителен, прежде чем пытаться декодировать

Рамка. Если конец кадра недействителен, он ДОЛЖЕН рассматривать это как фатальную ошибку протокола и закрывать

подключение без отправки каких-либо дополнительных данных. Он ДОЛЖЕН регистрировать информацию о проблеме,

поскольку это указывает на ошибку в реализации кода кадрирования сервера или клиента.

◆ Одноранговый узел НЕ ДОЛЖЕН отправлять кадры, размер которых превышает согласованный. Пир, получивший слишком большое

кадр ДОЛЖЕН сигнализировать об исключении соединения с кодом ответа 501 (ошибка кадра).

◆ Номер канала ДОЛЖЕН быть нулевым для всех контрольных кадров, а также для кадров метода, заголовка и тела.

которые относятся к классу Connection. Одноранговый узел, получивший ненулевой номер канала для одного из этих

кадры ДОЛЖНЫ сигнализировать об исключении соединения с кодом ответа 503 (недопустимая команда).

4.2.4 Полезные данные метода

Тела фрейма метода состоят из неизменяемого списка полей данных, называемых «аргументами». Все тела методов запускаются

с номерами идентификаторов для класса и метода:

0

2

4

+ ---------- + ----------- + -------------- - -

| идентификатор класса | идентификатор метода | аргументы ...

+ ---------- + ----------- + -------------- - -

коротко коротко ...

Рекомендации для исполнителей:

◆ Идентификатор класса и идентификатор метода являются константами, которые определены в классе и методе AMQP.

технические характеристики.

◆ Аргументы - это набор полей AMQP, специфичных для каждого метода.

◆ Значения идентификатора класса из% x00.01-% xEF.FF зарезервированы для стандартных классов AMQP.

◆ Значения идентификатора класса из% xF0.00-% xFF.FF (% d61440-% d65535) могут использоваться реализациями для

нестандартные классы расширения.

4.2.5 Поля данных AMQP

AMQP имеет два уровня спецификации полей данных: собственные поля данных, используемые для аргументов метода, и

поля данных, передаваемые между приложениями в таблицах полей. Таблицы полей содержат расширенный набор собственных данных

поля.

4.2.5.1 Целые числа

AMQP определяет эти собственные целочисленные типы:

◆ Беззнаковый октет (8 бит).

◆ Беззнаковые короткие целые числа (16 бит).

◆ Беззнаковые длинные целые числа (32 бита).

◆ Беззнаковые длинные длинные целые числа (64 бита).

Целые числа и длины строк всегда беззнаковые и хранятся в сетевом порядке байтов. Мы не пытаемся

оптимизировать случай, когда две системы с низким и высоким уровнем (например, два процессора Intel) взаимодействуют друг с другом.

Рекомендации для исполнителей:

◆ Разработчики НЕ ДОЛЖНЫ предполагать, что целые числа, закодированные в кадре, выровнены по слову памяти.

границы.

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 34 из 39

---

**Стр. 35**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Технические характеристики

4.2.5.2 Биты

AMQP определяет собственный тип битового поля. Биты накапливаются в целые октеты. Когда два или более бит

смежные в кадре, они будут упакованы в один или несколько октетов, начиная с младшего бита в каждом октете.

Не требуется, чтобы все значения битов в кадре были смежными, но обычно это делается для того, чтобы

минимизировать размеры кадра.

4.2.5.3 Строки

Строки AMQP имеют переменную длину и представлены целым числом, за которым следует ноль или более октетов

данные. AMQP определяет два собственных типа строк:

◆ Короткие строки, хранящиеся в виде 8-битового целого числа без знака, за которым следует ноль или более октетов данных. короткий

строки могут содержать до 255 октетов данных UTF-8, но не могут содержать октеты двоичного нуля.

◆ Длинные строки, хранящиеся в виде 32-битного целого числа без знака, за которым следует ноль или более октетов данных. Длинный

строки могут содержать любые данные.

4.2.5.4 Метки времени

Метки времени хранятся в 64-битном формате time_t POSIX с точностью до одной секунды. Используя 64 бита

мы избегаем будущих проблем с переносом, связанных с 31-битными и 32-битными значениями time_t.

4.2.5.5 Таблицы полей

Таблицы полей - это длинные строки, содержащие упакованные пары имя-значение. Пары имя-значение кодируются как

короткая строка, определяющая имя, и октет, определяющий тип значения, а затем само значение. Действительное поле

типы для таблиц являются расширением собственных целочисленных, битовых, строковых и временных типов и показаны в

грамматика. Многооктетные целочисленные поля всегда хранятся в сетевом порядке байтов.

Рекомендации для исполнителей:

◆ Имена полей ДОЛЖНЫ начинаться с буквы, «$» или «#» и могут продолжаться буквами, «$» или «#», цифрами или

подчеркивания, максимальная длина - 128 символов.

◆ Серверу СЛЕДУЕТ проверять имена полей и, получив недопустимое имя поля, СЛЕДУЕТ

сигнализировать об исключении соединения с кодом ответа 503 (синтаксическая ошибка).

◆ Десятичные значения предназначены не для поддержки значений с плавающей запятой, а для бизнес-значений с фиксированной запятой.

например, курсы валют и суммы. Они кодируются как октет, представляющий количество мест.

за которым следует длинное целое число со знаком. Октет десятичных знаков не подписан.

◆ Повторяющиеся поля недопустимы. Поведение однорангового узла по отношению к таблице, содержащей повторяющиеся поля

не определено.

4.2.6 Контент-фрейминг

Некоторые конкретные методы (публикация, доставка и т. Д.) Несут контент. См. Главу «Функциональные

Спецификации »для спецификаций каждого метода, а также того, содержит ли метод содержимое. Методы

которые несут контент, делают это безоговорочно.

Контент состоит из списка из 1 или более кадров, как показано ниже:

1. Ровно один фрейм заголовка содержимого, который предоставляет свойства содержимого.

2. Необязательно, один или несколько фреймов основного содержимого.

Кадры содержимого на определенном канале строго последовательны. То есть они могут быть смешаны с рамками для

другие каналы, но два кадра контента из одного канала не могут быть смешаны или перекрыты, а также не могут

Кадры содержимого для одного содержимого смешиваются с кадрами методов на том же канале.

Обратите внимание, что любой фрейм без содержимого явно отмечает конец содержимого. Хотя размер содержимого

хорошо известно из заголовка содержимого (и, следовательно, количества кадров содержимого), это позволяет

отправитель, чтобы прервать отправку контента без необходимости закрывать канал.

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 35 из 39

---

**Стр.36**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Технические характеристики

Рекомендации для исполнителей:

◆ Узел, получающий неполное или плохо отформатированное содержимое, ДОЛЖЕН вызвать исключение соединения.

с кодом ответа 505 (неожиданный фрейм). Это включает в себя отсутствующие заголовки контента, неправильные идентификаторы классов в

заголовки содержимого, отсутствующие рамки тела содержимого и т. д.

4.2.6.1 Заголовок содержимого

Полезные данные заголовка содержимого имеют следующий формат:

0

2

4

12

14

+ ---------- + -------- + ----------- + ---------------- + ------------- - -

| идентификатор класса | вес | размер тела | флаги собственности | список недвижимости ...

+ ---------- + -------- + ----------- + ---------------- + ------------- - -

короткие короткие длинные длинные

короткая

остаток ...

Рекомендации для исполнителей:

◆ Идентификатор класса ДОЛЖЕН соответствовать идентификатору класса кадра метода. Одноранговый узел ДОЛЖЕН ответить на недопустимый идентификатор класса.

путем создания исключения соединения с кодом ответа 501 (ошибка кадра).

◆ Поле веса не используется и должно быть равно нулю.

◆ Размер тела - это 64-битное значение, которое определяет общий размер тела содержимого, то есть сумму

размеры тела для следующих фреймов содержимого. Ноль указывает на отсутствие фреймов основного содержимого.

◆ Флаги свойств представляют собой массив битов, которые указывают наличие или отсутствие каждого значения свойства в

последовательность. Биты упорядочены от самого высокого к младшему - бит 15 указывает первое свойство.

◆ Флаги свойств могут указывать более 16 свойств. Если установлен последний бит (0), это означает, что

Далее следует поле флагов свойств. При необходимости имеется множество полей флагов свойств.

◆ Значения свойств являются полями данных AMQP для конкретных классов.

◆ Битовые свойства указываются ТОЛЬКО их соответствующим флагом свойства (1 или 0) и никогда не присутствуют в

список собственности.

◆ Номер канала в кадрах содержимого НЕ ДОЛЖЕН быть нулевым. Пир, который получает нулевой канал

номер в кадре содержимого ДОЛЖЕН сигнализировать об исключении соединения с кодом ответа 504 (ошибка канала).

4.2.6.2 Тело содержимого

Полезная нагрузка тела содержимого представляет собой непрозрачный двоичный блок, за которым следует октет конца кадра:

+ ----------------------- + + ----------- +

| Непрозрачная двоичная полезная нагрузка | | конец кадра |

+ ----------------------- + + ----------- +

Тело содержимого можно разбить на любое количество фреймов. Максимальный размер полезной нагрузки кадра составляет

согласовывается обоими узлами во время переговоров о соединении.

Рекомендации для исполнителей:

◆ Одноранговый узел ДОЛЖЕН обрабатывать тело содержимого, которое разделено на несколько кадров, сохраняя эти кадры как

единый набор, и либо ретранслируя их как есть, разбивая на более мелкие кадры, либо объединяя в

единый блок для доставки в приложение.

4.2.7 Кадры сердцебиения

Кадры тактового сигнала сообщают получателю, что отправитель все еще жив. Частота и синхронизация кадров сердцебиения

оговаривается при настройке соединения.

Рекомендации для исполнителей:

◆ Контрольные кадры ДОЛЖНЫ иметь нулевой номер канала. Одноранговый узел, получивший недопустимое сердцебиение

кадр ДОЛЖЕН вызывать исключение соединения с кодом ответа 501 (ошибка кадра).

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 36 из 39

---

**Стр. 37**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Технические характеристики

◆ Если одноранговый узел не поддерживает сердцебиение, он ДОЛЖЕН отбросить контрольный кадр без каких-либо сигналов.

ошибка или неисправность.

◆ Клиент должен начать посылать контрольные сообщения после получения метода Connection.Tune и начать

мониторинг пульса после получения Connection.Open. Сервер должен начать отправку и

мониторинг пульса после получения Connection.Tune-Ok.

◆ Одноранговый узел должен приложить все усилия, чтобы посылать биения с заданными интервалами. Сердцебиение можно отправить на

любое время. Любой отправленный октет является допустимой заменой тактового сигнала, поэтому тактовый сигнал должен быть отправлен только в том случае, если нет.

Трафик AMQP без контрольных сообщений отправляется дольше одного интервала контрольных сигналов. Если одноранговый узел не обнаруживает входящих

трафика (т. е. полученных октетов) в течение двух или более интервалов подтверждения, он должен закрыть соединение без

после установления связи Connection.Close / Close-Ok и зарегистрируйте ошибку.

◆ Сердцебиение должно продолжаться до тех пор, пока разъем подключения не будет закрыт, в том числе во время и после

Connection.Close / Close-Ok подтверждение связи.

**4.3 Мультиплексирование каналов**

AMQP позволяет одноранговым узлам создавать несколько независимых потоков управления. Каждый канал действует как виртуальный

соединение, использующее один сокет:

рамы рамы рамы рамы

+ ----------- + ----------- + ----------- + ----------- +

| канал | канал | канал | канал |

+ ----------- + ----------- + ----------- + ----------- +

|

разъем

|

+ ----------------------------------------------- +

Рекомендации для исполнителей:

◆ Одноранговый узел AMQP МОЖЕТ поддерживать несколько каналов. Максимальное количество каналов определяется в

согласование соединения, и одноранговый узел МОЖЕТ согласовать это до 1.

◆ Каждому одноранговому узлу СЛЕДУЕТ справедливо балансировать трафик на всех открытых каналах. Эта балансировка может быть

выполняется покадрово или в зависимости от объема трафика на канал. Одноранговому узлу НЕ СЛЕДУЕТ

позволить одному очень загруженному каналу замедлить продвижение менее загруженного канала.

**4.4 Гарантия видимости**

Сервер должен гарантировать, что наблюдения клиента за состоянием сервера согласованы.

Следующий пример иллюстрирует, что означает наблюдение клиента в этом контексте:

◆

Клиент 1 и Клиент 2 подключены к одному и тому же виртуальному хосту

◆

Клиент 1 объявляет очередь

◆

Клиент 1 получает Declare.Ok (пример "наблюдения")

◆

Клиент 1 сообщает об этом Клиенту 2

◆

Клиент 2 выполняет пассивное объявление той же очереди

Гарантия видимости гарантирует, что Клиент 2 видит очередь (при отсутствии удалений)

**4.5 Закрытие канала**

Сервер будет считать канал закрытым, если произойдет одно из следующих событий:

1. Либо одноранговый узел закрывает канал, либо родительское соединение, используя рукопожатие Close / Close-Ok.

2. Либо одноранговый узел вызывает исключение на канале, либо в родительском соединении.

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 37 из 39

---

**Стр. 38**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Технические характеристики

3. Любой из партнеров закрывает родительский сокет подключения без квитирования Close / Close-Ok.

Когда сервер закрывает канал, все неподтвержденные сообщения на канале помечаются для повторной доставки.

Когда сервер закрывает соединение, он удаляет все автоудаления, принадлежащие этому соединению.

**4.6 Синхронизация контента**

В некоторых случаях синхронные методы запроса-ответа влияют на асинхронную доставку контента.

на том же канале, в том числе:

◆ Методы Basic.Consume и Basic.Cancel, которые запускают и останавливают поток сообщений от

очередь сообщений.

◆ Метод Basic.Recover, который просит сервер повторно доставить сообщения в канал.

◆ Методы Queue.Bind, Queue.Unbind и Queue.Purge, которые влияют на поток сообщений в

очередь сообщений.

Рекомендации для исполнителей:

◆ Эффекты запроса-ответа НЕ ДОЛЖНЫ быть видимы на канале до метода ответа,

и ДОЛЖЕН быть виден после этого.

**4.7 Гарантии заказа контента**

Порядок передачи методов по каналу стабилен: методы принимаются в том же порядке, в котором они поступают.

послал. Это гарантируется транспортом TCP / IP, используемым AMQP. Далее содержимое обрабатывается в

стабильно сервером. В частности, содержимое, проходящее по одному пути на сервере, будет

остаются заказанными. Для содержимого с заданным приоритетом, проходящего по единственному пути, мы определяем содержимое

тракт обработки, состоящий из одного входящего канала, одного обмена, одной очереди и одного исходящего

канал.

Рекомендации для разработчиков:

◆

Сервер ДОЛЖЕН сохранять порядок содержимого, проходящего через единственный путь обработки содержимого,

если поле повторно доставлено не установлено в методах Basic.Deliver или Basic.Get-Ok, и в соответствии с

правила, регулирующие условия, при которых может быть установлено это поле.

**4.8 Обработка ошибок**

4.8.1 Исключения

Используя стандартную модель программирования «исключений», AMQP сигнализирует не об успехе, а только об ошибке. AMQP

определяет два уровня исключения[](https://translate.googleusercontent.com/translate_f#38)[1](https://translate.googleusercontent.com/translate_f#38)[](https://translate.googleusercontent.com/translate_f#38):

1. **Исключения каналов** . Они закрывают канал, вызвавший ошибку. Исключения каналов обычно

из-за «мягких» ошибок, которые не влияют на остальную часть приложения.

2. **Исключения подключения** . Они закрывают соединение сокета и обычно возникают из-за «серьезных» ошибок, которые

указывает на ошибку программирования, неправильную конфигурацию или другой случай, требующий вмешательства.

Мы формально документируем утверждения в определении каждого класса и метода.

4.8.2 Формат кода ответа

Коды ответа AMQP соответствуют определению «Уровни и теория кода ответа» из IETF RFC 2821.

1

Серьезность этих исключений может удивить читателя, однако AMQP нацелен на системы, которые либо работают

предсказуемо или нет, используя шаблон ASSERT, общий из лучших программных практик.

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 38 из 39

---

**Стр. 39**

Авторское право (c) 2006-2008. Все права защищены. См. Уведомление и Лицензия.

Технические характеристики

**4.9 Ограничения**

Спецификации AMQP накладывают эти ограничения на будущие расширения AMQP или протоколов того же

формат на уровне проводов:

◆ Количество каналов на одно соединение: 16-битный номер канала.

◆ Количество классов протокола: 16-битный идентификатор класса.

◆ Количество методов на класс протокола: 16-битный идентификатор метода.

Спецификации AMQP накладывают следующие ограничения на данные:

◆ Максимальный размер короткой строки: 255 октетов.

◆ Максимальный размер длинной строки или таблицы полей: 32-битный размер.

◆ Максимальный размер полезной нагрузки кадра: 32-битный размер.

◆ Максимальный размер контента: 64-битный размер.

Сервер или клиент также могут налагать собственные ограничения на ресурсы, такие как количество одновременных

соединения, количество потребителей на канал, количество очередей и т. д. Они не влияют на совместимость.

и не указаны.

**4.10 Безопасность**

4.10.1 Цели и принципы

Мы защищаемся от эксплойтов, связанных с переполнением буфера, за счет использования повсюду буферов с заданной длиной. Все внешне-

предоставленные данные могут быть проверены на соответствие максимально допустимой длине при чтении любых данных. Неверные данные

можно обработать однозначно, закрыв канал или соединение.

4.10.2 Атаки отказа в обслуживании

AMQP обрабатывает ошибки, возвращая код ответа, а затем закрывая канал или соединение. Это позволяет избежать

неоднозначные состояния после ошибок. Сервер должен предполагать, что исключительные условия во время подключения

стадии переговоров связаны с враждебной попыткой получить доступ к серверу. Общий ответ на любой

исключительным условием при согласовании соединения является приостановка этого соединения (предположительно потока) для

на несколько секунд, а затем закрыть сетевое соединение. Сюда входят синтаксические ошибки, слишком большие

данные и неудачные попытки аутентификации. Серверу СЛЕДУЕТ регистрировать все такие исключения и отмечать или блокировать

клиенты провоцируют множественные сбои.

Спецификация протокола расширенной очереди сообщений v0-9-1

Страница 39 из 39